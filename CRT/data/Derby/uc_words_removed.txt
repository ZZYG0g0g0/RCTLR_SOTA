Currently stream writing methods network server client require length parameter means get length stream sending example network server EXTDTAInputStream use getString getbytes instead getCharacterStream getBinaryStream get length SQLAM Level 7 provides enhanced LOB processing allow streaming without indicating length writeScalarStream methods network server network client changed require length Code inspection methods seems indicate length never written used heavily generating DSS One strange thing appears error stream padded full length zeros actual exception never sent Basically think perhaps methods need rewritten scratch based spec requirements lobs writeScalarStream methods changed EXTDAInputStream changed properly stream LOBS See TODO tags file info guessing similar optimizations available client well sure code
unlimited least make 80 pick abitrary number
would nice supported NATURAL JOIN syntax feature
Provide implementation ROLLUP form grouping according SQL standard See detailed information aspect SQL standard
Cloudscape used expose Virtual Table Interfaces class implemented ResultSet could included query list still exposes number VTIs diagnostic tools However prevents customers declaring VTIs parser raises error VTI package one diagnostic packages powerful feature customers use solve many problems discuss reasons disabled come plan putting power back customers hands
Would like see support added sequences would permit select sequence always obtain ever value identity column works fine times applications application needs obtain sequence number use prior database write Subsequent calls would result new number call SQL following SELECT NEXT VALUE sometable would result next value
gt DistinctScalarAggregateRS implement close finish method gt gt sure difference close scan controller close finish methods actually explained javadoc language class 91 note JDBC object 93 close Tells system calls getNextRow next open call finish Tells system access database information via result set close means ResultSet may opened access finish means used However use code always match cause confusion least Language ResultSets JDBC ones opened multiple times example scanning table multiple times within join Activation represents internal state object amp lifetime contains language ResultSet language ResultSet provides execution SQL statement DML DDL query ResultSet may contain ResultSets could seen tree structure simple case primary key lookup query like select name customer id activation would contain top result set ProjectRestrictRS lt lt IndexRowToBaseRowRS lt lt TableScanRS reason even though api ResultSet say cases result set tree thrown away execution top result set finish method called activation removes reference next execution new identical tree set potential huge performance gain top level result set tree lifetime Activation saving comes two forms create many objects execution creating objects garbage collector handle made simple fix couple lines code calling close amp finish correct times simple primary key lookup query performance went selects per second cached data single user post patch shortly indication direction separate changes client However running tests maybe failures think language ResultSet implementations correctly written Interestingly first failure saw aggregrate test goes back issue Manish saw Even derbyall passed would nervous submitting patch real think lot testing using repeat executions PreparedStatements tests ij tests mainly use Statement single use activation change would affect Thus patch could regress making likely existing bugs would exposed Given performance gains think need start ResultSets Activation devise way ensure testing covers main issue large number ResultSet implementations cover
Currently client driver data executeQuery called first call data executeQuery would reduce network traffic improve performance DRDA protocol supports description OPNQRY open query qryrowset parameter specifies whether rowset rows returned command honored scrollable cursors QRYATTSNS equal QRYSNSDYN cursors conforming limited block query protocol target server fetches requested number rows may fetch fewer rows restricted extra query block limits fetch operation results negative SQLSTATE SQLSTATE 02000
JDBC API introduced ability rows resultset using methods Java programming language rather send SQL command Jira entry track insert rows functionality using JDBC apis
Implement layer B streaming new methods defined JDBC introduced new methods take parameters object sent sever without length information methods Layer B streaming best way implement sending object server issue representation Network Client
API network server engine well defined leading inconsistent amp multiple ways handling different objects returned reflection explicit casting etc turn lead bugs access underlying objects application hidden Define interfaces EngineConnection EmbedConnection BrokeredConnection implement Thus network server rely fact connection obtains implement EngineConnection call required methods interface likely need EngineConnection EnginePreparedStatement EngineResultSet interfaces would internal exposed applications
database created logDevice pointing directory containing old log files one might experience errors recovery ERROR XSDB4 Page Page 0 Container 0 768 version log file contains change version either log records page missing page get written disk properly avoid problem database creation fail logDevice pointing existing directory
Change internal implemetation share existing alter table code One suggested approach use mechanism implementation would involve change parser alter table accecpt internal syntax change alter table constant action get required information inplace compress move inplace compress driving code routine alter table execution following coding pattern existing alter table compress believe multiple benefits 1 shares existing alter table code things like error checking security management done one piece code 2 sharing code believe following outstanding JIRA issues addressed 3 future changes addressing ddl like automatically work
Add jdbc40 suite test verifies JDBC4 classes satisfy expected signatures
Currently encrypt unencrypted database change encryption key already encrypted database However expose way turn unencrypt already encrypted database
encrypted database new password ideas initial implementation easiest way make sure exclusive access data log required new copy db want avoid log also encrypted high level plan 1 Force exclusive access putting work low level store offline boot method redo recovery usual end entry point operation process 0 request db handled new set url flags passed store boot time new flags provide inputs current encrypt flags high level request connect db TODO provide exact new flag syntax 1 Open transaction logged work encryption logging done existing encryption 2 Copy encrypt every db file database target files data directory new suffix track new files similar current process used handling drop table transaction consistent manner without logging entire table log Entire encrypted destination file guaranteed synced disk transaction commits think part needs logged Files read cache using existing mechanism written directly new encrypted files new encrypted data end cache 3 Switch encrypted files old files new log operation process correctly rolled back encrypt db operation transaction fails Rollback file time switches reading encrypted data necessary 4 log change encryption db log record update change 5 commit transaction 6 update sync changes 7 TODO need someway handle crash steps 5 6 6 checkpoint data point guaranteed outstanding transaction checkpoint done need log ISSUES probably something catches request encrypt whatever db already encrypted
run VerifySignatures test see lot JDBC4 methods appear implementation yet need add vacuous implementations methods raise SQLFeatureNotSupportedExceptions methods need attention refer features like xml national strings support open additional JIRAs methods need implementations
ij accept help option print command line syntax reference friendliness
next rev JDBC4 spec clarify databases raise SQLException application calls methods closed sql objects ResultSet Preparedstatement CallableStatement Connection Statement verify conform
upcoming release move isPoolable setPoolable PreparedStatement Statement conform
Handle interrupt received waiting database lock Subtask issue tracks changes needed handle interrupt received thread waiting database lock Let query stop execution interrupt seen time check query timeout Subtask BasicNoPutResultSetImpl checkCancellationFlag currently check whether statement canceled timed certain times query execution would like interrupt seen execution hitherto also throw point Cf way also stop execution batches batch element sees interrupt
Implement Right methods implemented network client embedded client
Currently client tracing enabled setting attributes client url setXXX methods DataSource calling often enabled deployed client application API require modification application configuration files would good global way turn client tracing system property pointing property file one possibility probably ideal impact class loader contexts sure possiblities
Detectability changes implemented client using warnings cf row deleted updated warning sent client indicate fact Presently one warning sent time data row sent client means warnings may lost Using extended diagnostic allows us send several warnings data row propose use extended diagnostics send warnings necessary may later extended warnings plan part work issue
table index stored separate file Space deleted rows eventually reclaimed within file used subsequent inserts file space returned OS unless user calls system procedure procedure return unused space tables indexes OS gets exclusive lock table copies rows indexes base table new compressed files delete old files Prior jdk way return space file OS jdk RandomAccessFile enhanced allow truncation file would return space end file back OS order take advantage new feature new compress feature needed assumption work used future work automatically schedule job others background interaction needed dba 1st phase work simply build procedure work 2nd phase look scheduling procedure automatically part current background post commit processing Longer term would best fit new background task monitor could schedule larger background tasks balanced priorities system tasks might include new online compress automatic statistics gathering proactive deleted row reclamation proposed feature reorganize base tables indexes moving empty pages end release space back operating system created chunk empty pages end file designed run background lock resources table short time possible iteratively process table reclaim space heap scan heap page reverse order get short term table lock process rows page commit transaction releasing lock commit optimized like internal transactions need wait synchonized write row moved require index entries row also updated processing also take care processing committed deleted rows space free end table freed back operating system using interface reclaim space btree data pages moved rather rows Data pages end file moved free smaller numbered pages short term table locks required operation look similar current btree merge operations already implemented chunk pages free end file returned OS using mechanism heap
antiGC thread originally created avoid DriverManager class garbage collected refrences existed loaded embedded JDBC driver hence shutting engine issue JDK Since support garbage collection classes clearly defined possible thread serves useful purpose
task involves Adding modifying following methods recently added JDBC4 expert group appeared Mustang build 86 add int columnIndex InputStream x long length add int columnIndex InputStream x long length add int columnIndex Reader x long length add String columnName InputStream x long length add String columnName InputStream x long length add String columnName Reader x long length add int columnIndex InputStream x long length add int columnIndex InputStream x long length add int columnIndex Reader x long length add String columnName InputStream x long length add String columnName InputStream x long length add String columnName Reader x long length add int columnIndex InputStream x long length add String columnName InputStream x long length add int columnIndex Reader x long length add String columnName Reader x long length add int columnIndex Reader x long length add String columnName Reader x long length modify int columnIndex Reader x int length int columnIndex Reader x long length modify String columnName Reader x int length String columnName Reader x long length
streaming data application stream wrapped stream convert data correct representation minimum consists getting data format used wrapping stream extended provide following features earlier stage Data maximum allowed size exceeded b Truncation trailing blanks allowed features reduce amount data needed kept memory insertion Implementing require additional type information streaming class es implementation must able handle streams length specified also streams length
Currently four diagnostic tables exist provide information running state error messages tables invoked using awkward syntax example SELECT NEW improvement provide internal mapping regular table name schema runtime virtual table code Thus example would replaced SELECT diagnostic table expressions regular table expressions NEW VTI construct used wherever normal table DDL compression procedure etc references diagnostic table result exception old style syntax remain place become deprecated tables implemented change replaces replaces replaces replaces Adding table table driven thus easy others provide additional diagnostics Information diagnostic tables appear system catalogs JDBC DatabaseMetaData ResultSetMetaData query involving diagnostic table valid first step progression towards supporing fully defined virtual table steps part jira issue added information purposes second step supporting diagnostic tables parameters SELECT sales orders third step providing create virtual table statement databases support form virtual table wrappers DDL would data access would standard 91 need check table functions part 13 SQL standard 93 syntax yet defined give general idea CREATE VIRTUAL TABLE TICKER VARCHAR 10 START TIMESTAMP END TIMESTAMP LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME
Provide way drop column existing table Possible syntax would ALTER TABLE tablename DROP COLUMN columnname CASCADE RESTRICT Feature properly handle columns used constraints views triggers indexes etc
EmbedPreparedStatement EmbedResultSet many occurrences switch case case case case break default throw dataTypeConversion switch case case case case break default throw dataTypeConversion Instead many copies code would good factor methods shared instance one could add methods DataTypeDescriptor public static boolean isAsciiStreamCompatible int jdbcType public static boolean isBinaryStreamCompatible int jdbcType public static boolean isCharacterStreamCompatible int jdbcType
JDBC4 expert group made following changes spec changing name getFunctionColumns constants changing name functionColumn
getDatabaseProductVersion getDriverVersion report four digit version number svn build number would useful return full version including build number sysinfo 392472 way clear application logs collect information exactly revision level running using rolled fixes maintenance branch releases may risk however applications parsing version information hopefully use getDatabaseMajorVersion getDatbaseMinorVersion getDriverMajorVersion getDriverMinorVersion proccessing
heavy use static state information existing harness major mistake repeated Junit model changed many tests written static configuration limit ability tests flexible different instances running different configurations instance based scheme flexible change change api current implementation single static configuration remain hidden within
Idea drop objects based upon input DatabaseMetaData system catalogs meta data insufficient Would allow Junit tests share databases incrementally developed used first step drop views tables etc etc
work amp discovered DependencyMangerImpl loaded Provier multiple times DataDictionary loading stored dependecies converting form need load Provider DataDictionary passed call results loading stored dependencies
currently allow CALL statement used trigger body would great allow java stored procedure invocation inside trigger Since SQL procedure language triggers execute single SQL statement allow stored procedures triggers would possible write trigger involves one SQL statement Functions currently allowed believe fairly easy support enhancement Need good amount testing though
Useful running ij SQL scripts part JUnit tests applications use instead awkward way use ij program today Run SQL script input stream write resulting output provided OutputStream param conn Connection used script default connection param sqlIn InputStream script param inputEncoding Encoding script param sqlOut OutputStream script output param outputEncoding Output encoding use return Number SQLExceptions thrown execution known throws UnsupportedEncodingException public static int runScript Connection conn InputStream sqlIn String inputEncoding PrintStream sqlOut String outputEncoding throws UnsupportedEncodingException
TestConfiguration uses determine JDBC 4 supported Ideally test code calling engine private api code Suggest two changes 1 Determine JDBC level support ability load classes JDBC2 JDBC3 JDBC4 JSR169 2 Move supportsJDBC4 method TestConfiguraiton JDBC since VM supports JDBC4 attribute test configuration add supportsJDBCX methods
part ACCSECRD server accept security mechanism sent client server send list security mechanism supports Currently even server running sun jvm still send EUSRIDPWD sec mec supports incorrect server test support EUSRIDPWD dynamically send EURRIDPWD option supports see int
UNION node generate byte code call method NoPutResultSet getUnionResultSet NoPutResultSet source1 NoPutResultSet source2 Activation activation int resultSetNumber double optimizerEstimatedRowCount double optimizerEstimatedCost GeneratedMethod closeCleanup closeCleanup method passed null result sets tree except top one Instead passing new result set would much efficient setCloseMethod called top result set Could also look closeCleanup method interface call directly rather reflection applies node takes closeCleanup method Split
currently use correlation ID statement makes cumbersome following UPDATE SET BONUS SELECT SUM BONUSES use correlation ID makes easier code UPDATE EMPLOYEE E SET BONUS SELECT SUM BONUSES B particularly important get carried away long SCHEMA TABLE names
default MySQL case insensitive string comparisons see MySQL docs shown Similar functionality available Sybase iAnywhere SQLServer like true wonder chances aware functions could used force comparisons upper case subverts indexes makes searches unacceptably long ask people might find feature whose abscence causing many look elsewhere thanks great work Terry MySQL Docs say start quote default MySQL searches case sensitive although character sets never case insensitive czech means search LIKE get column values start want make search case sensitive make sure one operands case sensitive binary collation example comparing column string latin1 character set use COLLATE operator cause either operand collation example COLLATE LIKE LIKE COLLATE COLLATE LIKE LIKE COLLATE want column always treated fashion declare case sensitive binary collation See Section CREATE TABLE Syntax default search performed fashion MySQL make search using binary collation indexed columns example column character set latin1 assigned collation make case sensitive searches end quote
revoke execute restrict fail dependent objects execute privilege per functional spec attached revoke execute restrict fail dependent objects execute privilege order implement revoke execute executed special invalidation action sent dependent objects need catch invalidation throw exception dependents exception thrown revoke execute succeed creating new jira entry easier track sub items link Jira entry See functional spec attached view dropped privilege required view revoked view tracks privileges requirements using Dependency Manager one required privileges revoked view dropped automatically creating new jira entry easier track sub items link Jira entry See functional spec attached Upgrade test needs enhanced test grant revoke Grant Revoke one features targeted Release upgrade test modified test feature various upgrade scenarios make sure everything works fine add derbynetclientmats noticed running client fails gt Unexpected exception gt 08004 Connection authentication failure occurred Reason userid password invalid gt Connection authentication failure occurred Reason userid password invalid gt Caused Connection authentication failure occurred Reason userid password invalid gt 8 gt FAILED 1 error Test Failed End grantRevoke DerbyNetClient Perhaps test configuration problem sort would good client testing grant revoke Remove added Grant Revoke functionality Grant Revoke functionality engine needs keep track dependencies various privileges table added purpose depdencies mantained using existing Dependency Manager done quite bit work using Dependency Manager Grant Revoke see need release drop code update functional spec accordingly trigger dropped privilege required trigger revoked trigger tracks privileges requirements using Dependency Manager one required privileges revoked trigger dropped automatically creating new jira entry easier track sub items link Jira entry See functional spec attached constraint dropped privilege required constraint revoked constraint tracks privileges requirements using Dependency Manager one required privileges revoked constraint dropped automatically creating new jira entry easier track sub items link Jira entry See functional spec attached
Grant revoke functionality added comments went grant revoke code places refer database owner dba thing grant revoke world dba role added roles yet current use dba comments might make confusing start working roles including dba
Adds following functions SIGN 0 1 zero positive negative arguments SQRT Square root RAND Random number RANDOM COSH Hyperbolic Cosine SINH Hyperbolic Sine TANH Hyperbolic Tangent
currently developing system load 1000 5000 objects one go user load different chunks objects time navigating system consist java application accesses via hibernate profiling discovered biggest bottleneck system method SQLEqualsIgnoreCase String s1 String s2 upperCase s1 s2 time putting uppcase value Hashtable using key increates performance 40 report system seems run double speed class calling case class also checked seems lot looping might canditate hashing stated code REVISIT might want cache info diff agains source 22a23 gt import lt return 8212 gt gt String s1Up String s1 gt s1Up null gt gt s1Up gt s1 s1Up gt gt String s2Up String s2 gt s2Up null gt gt s2Up gt s2 s2Up 321a334 gt return s2Up gt gt gt gt private static Hashtable uppercaseMap new Hashtable
JPA requiring databases support ANSI feature esp ability chose trimmed character TRIM str
EmbedResultSet creates holds references information logically plan level ResultSet use prepared plan Holding information EmbedResultSet hurts performance memory usage ResultSet objects short lived Saving ResultSetMetaData object ResultDescription object means single creation lifetime plan shared across connections rather per ResultSet object needed Saving column name position mapping added ResultDescription similar benefit map set per prepared plan per executeQuery test changes attach patch soon performance derby1862 test improves around 15
documentation need updated committed reference manual need describe use new ALTER TABLE DROP COLUMN feature drop column table documentation ALTER TABLE command becoming somewhat unwieldy perhaps way restructure page make easier approachable documentation important clearly describe RESTRICT CASCADE behaviors users may confused things cause RESTRICT refuse drop column comments may help Specifically documentation note possibly unexpected behaviors column present one indexes indexes cause RESTRICT refuse drop column Instead column simply dropped index last column index entire index dropped Explicitly named CHECK constraints cause RESTRICT refuse drop column PRIMARY KEY FOREIGN KEY UNIQUE constrants However unnamed simple NULL constraint column cause RESTRICT refuse drop
presently implement support method similarly supplied value null unless type argument 3rd arg also present void setObject int parameterIndex Object x throws SQLException x null presently throw SQLException client XJ021 embedded 22005 x null calling method preparedStatement Porting applications may made easier restriction lifted See also discussion
Statement ParameterMetaData contain flags called flags might function always false used many make code harder read Removing flags code executed flags true would simplify code make maintainable
Every method calls setUpSocket call new closeSocket method
currently supports following JDBC methods keys Indicate want retrieve key values String sql int autoGeneratedKeys String sql int autoGeneratedKeys String sql int autoGeneratedKeys Retrieve values applies INSERT statements ResultSet rs current implementation getGeneratedKeys internally maps method means implementation returns generated keys autoincrement columns default columns supported 1 generated key result set ever single column allows one autoincrement column per table 2 type single column result set DECIMAL defined 3 generated key result set ever single row returns values assigned result single row INSERT statement using VALUES clause single row INSERT statement one autoincrement value generated said JDBC also defines following methods allow user explicitly indicate via column position column name columns keys made available String sql String columnNames String sql int columnIndexes String sql String columNames String sql int columIndexes String sql String columnNames String sql int columnIndexes currently throws Feature supported error methods However seems like methods could mapped onto existing behavior relatively little effort embedded mode required code already place would make easier applications rely columnNames columnIndexes APIs work assuming app wants generated keys identity autoincrement columns Note Jira entail removing restrictions changing behavior outlined remain exactly Jira simply exposes existing functionality restrictions additional standard API methods particular means column specified index position name must column INSERT table otherwise throw error put differently user specifies column absence errors exact results would get invoking String sql int autoGeneratedKeys method Note also Jira specifically embedded mode think would harder support methods Client plan address
Rewrite test JUnit using utility methods added
session Apachecon 2006 Austin included demo showing use Java functions procedures inside engine would like check demo demo directory
Need work current failures running NistScripts due blank lines generated constraint names output
writing transaction log disk uses RandomAccessFile supported JVM log files opened rws mode making file system take care syncing writes disk rws mode ensure data file updated every write file operating systems Solaris leads two write operation disk every write issued limiting throughput update intensive applications could change file mode rwd could reduce number updates disk run simple tests changed mode rws rwd log file running small numbers concurrent client threads throughput almost doubled response time almost halved attach graphs show running given number concurrent like clients graphs show throughput running rws rwd mode disk write cache enabled disabled creating Jira place collect information issues changing default mode writing log files
Make client driver treat BOOLEAN columns way embedded driver operation currently allowed BOOLEAN columns select system tables instance following query selects BOOLEAN values select systemalias discrepancies embedded client drivers handle BOOLEAN columns embedded behavior correct client behavior conform attach spec describing needs done Allow functions return BOOLEAN values part expanding support BOOLEAN datatype would nice allow functions return BOOLEAN values Allow explicit casts string values BOOLEAN SQL Standard allows strings explicitly cast BOOLEAN values Strings type BOOLEAN cast BOOLEAN part expanding support BOOLEAN datatype allow casts Casting string types boolean defined part 2 section lt cast specification gt general rule 20 Trim whitespace string b apply rules section lt literal gt means trimmed string must TRUE FALSE UNKNOWN regardless case c Otherwise raise exception Allow routines take arguments BOOLEAN type allow routines take BOOLEAN arguments part expanding support BOOLEAN datatype Make possible table functions return BOOLEAN columns Right function return table BOOLEAN column Enable BOOLEAN typed columns Allow tables boolean columns
methods PageKey class called frequently lock manager cache manager Since classes extend declared final help compiler optimize method calls
Since compilinga statement returning specific node makes sense lead little clarity code methods defined QueryTreeNode generate needsSavepoint move StatementNode thus make code readable generate called value node remove implementations methods never called
Latching pages could done efficiently locally store lock manager See discussion
DataDictionaryContext adds complexity getting reference data dictionary old code used push multiple dictionaries code longer exists
synchronized collection objects could replaced unsynchronized ones See discussion
Convert junit Convert junit Convert junit Convert junit Convert JUnit executes DRDA commands file written language statements much like assertions fairly easy convert test JUnit Suggested approach Change interpreter uses instead instead also use TestConfiguration get host name port number Convert JUnit Convert JUnit client setTransactionIsolation executes commits even isolation changed check see isolation level return without commit public void setTransactionIsolation int level throws SQLException level getTransactionIsolation return check would good client driver acted like embedded Finish client info api JDBC4 Compliance task following methods need finished getClientInfo getClientInfo setClientInfo Implement implemented Embedded methods long pos long length long pos long length following methods introduced interface part JDBC need implemented Clob getCharacterStream long pos long length Blob getBinaryStream long pos long length implementation Network Client already done part Expose existing key functionality JDBC APIs Client See details Desired functionality except issue specifically Client addressed embedded mode Detailed prompt Error XCL16 different Client Embed sql script create table t1 c11 int c12 int 8211 insert data tables insert t1 values insert t1 values 8211 set autocommit autocommit get nohold cursor jdk1 SELECT t1 8211 fetches cursor next jdk1 commit commit 8211 try fetch cursor commit 8211 cursors jdk1 give Error XCL16 next jdk1 8211 clean close jdk1 line next jdk1 Error XCL16 thrown However detailed prompt Error XCL16 different Client Embed client mode get ERROR XCL16 ResultSet open Verify autocommit embed mode get ERROR XCL16 ResultSet open Operation next permitted Verify autocommit Different behavior Client Embedded modes update invalid cursor Consider sql snippet create table test c1 int c2 int insert test values update test set current jdk4 update line get ERROR XJ202 Invalid cursor name JDK4 Client mode ERROR 42X30 Cursor JDK4 found Verify autocommit Embed mode Change sysinfo print specific JVM information would nice sysinfo printed specific jvm information provided java least IBM jvm system properties give information research needed across multiple jvms tie Alternatively sysinfo could dump system property information could make output pretty big show irrelavant information contexts Behaviour setTypeMap differs embedded client embedded driver behaves like connection closed map argument null throw SQLException SQLState XJ081 map null empty throw SQLException SQLState 0A000 map null empty nothing behaviour client driver always throw SQLException SQLState 0A000 try make two drivers behave way setTypeMap called would also allow us simplify tests J2EEDataSourceTest inefficient reading one byte time source BLOB inefficient since reading one byte time source BLOB would better transfer buffer used facilitate write Release system resources CanonTestCase thoroughly method compareCanon String canon CanonTestcase two BufferedReaders cannonReader testOutput closed try catch block however exception occurs two BufferReaders closed related system resources released Besides releative problem ByteArrayOutputStream rawBytes CanonTestcase created getOutputStream closed compareCanon String canon pointed Knut ByteArrayOutputStream javadoc says closing effect tearDown method added CanonTestCase sets rawBytes null certainly work However also OK null rawBytes compareCanon String canon seems cleaner null tearDown method
allows user change interval consecutive values identity column using ALTER TABLE way change next value generated identity column support handy tables identity column defined GENERATED DEFAULT unique key defined Column defined GENERATED DEFAULT allows system generate values allows user manually supply value column defined way useful user might want import data generated column manually create problems system generated values conflict manually inserted values eg autocommit create table tauto int generated default identity k int create unique index tautoInd tauto insert tauto k values 8211 let system generate values identity column 8211 manual inserts identity column insert tauto values insert tauto values insert tauto values insert tauto values insert tauto values insert tauto values 8211 notice identity column point used 1 8 8211 user wants let system generate value system generate 3 already used hence 8211 insert throw unique key failure exception System consumed 3 point insert tauto k values 9 8211 insert continue fail unique key failure exceptions system consumed values till 8 8211 add ALTER TABLE syntax allow changing next value generated user simply use change 8211 next value generated 9 manual inserts insert tauto k values 9 fail SQL standard syntax changing next generated value ALTER TABLE lt tablename gt ALTER lt columnName gt RESTART
probably safe replace synchronized collections unsynchronized ones investigated unnecessary synchronization removed See discussion
Expand work support remaining diagnostic tables take parameters Syntax would use table constructor like sure clause required select TABLE Diagnostic VTIs could handled way ErrorLogReader String log file name SpaceTable String tableName SpaceTable String schemaName String tableName StatementDuration String inputFileName second stage mentioned
used base projects standalone SQL syntax checker discussed
timeout set session socket ClientThread SocketTimeoutException taken care Connections therefore closed set client idles longer timeslice See details
code locking row holding latch seem used outside unit tests store code removed order reduce overall complexity See discussion details
simple performance junit framework added part number improvements suggested please see jira add new performance tests tests easily available anyone run report issues fix issues etc
1 good perform testing different jvm classpaths included typically used embedded environment 2 Running tests platofrms supported jars platform supports class path Currently running hits error Failed invoke suite
class SPSDescriptor kind hard understand quite follow pattern used tuple descriptors Parts code agree documentation marked implemented issue tracks work make class easier understand modify critical part may need changed use synchronized problem database locks obtained within critical regions special cases causes deadlocks yet certain fixed level continue investigation
would like enable old test harness support new version IBM j2ME implementation based j2ME jdk spec version available product named Websphere Everyplace Micro Edition IBM already support matches j2ME jdk spec like add matches j2ME jdk spec proposing switch automated tests newer version going forward minimize complexity change like make canons reflect behavior new version differences minimal However want able still run old except results differ failures would occur old version One reasons moving new version bug older version regards security manager preventing smooth run junit tests like run tests derbyall least one versions Another reason j2ME spec really old
Create test DatabaseMetaData matches testing also handle variant created used tests ensure database meta data works situations upgrade databases
JIRA separates powers system privileges master security JIRA Restrict following powers database owner moment shutdown upgrade encryption
get updatable result set JDBC spec section Modifying ResultSet Objects states ResultSet objects concurrency updated using ResultSet objects addition requires SQL SELECT statement UPDATE clause updates allowed may usability issue many examples JDBC API tutorial reference reference book JDBC Specification include UPDATE clause SQL SELECT Mamta Satoor says implements JDBC updatable resultset using existing updatable cursor implementation order requires SELECT statement include UPDATE clause One change implementation require UPDATE clause piggyback updatable cursor implementation Dan DeBrunner says Technically wonder covered JDBC standard see nothing JDBC states requirements SQL statement updateable result set know JDBC tutorial book guidelines typically work database engine define works said think requiring UPDATE would useful improvement
Disallowing routines accessing code directly stops potential remote code exploiting security holes code seen special case since known code classpath Disallowing routines makes security analysis easier safer rather trying guarantee every public static method expose secured information Routines existing applications upgraded databases map methods fail execute time
Implement DETERMINISTIC keyword procedures functions need DETERMINISTIC functions implement generated columns syntax behavior DETERMINISTIC keyword defined functional spec attached Add tests generated columns sql authorization turned Add tests generated columns sql authorization instance need verify appear generation clauses
Since open source obviously contains code read database files modular potential exists routines could utilize code classpath database information directly bypassing SQL level security special case known code classpath correct permissions database files Existing routines upgraded databases fail execute time try resolve classes
Default SSL behaviour require serer authentication database application important web browsers also creates som extra hassle programmer Since main objective SSL encryption wire server authentication optional way client authentication also creates symmetry exploited simplify user interfce somewhat improvement described attached functional specification See attachment details
trying learn access layer discovered code improvements could easily made increase readability code Patches attached issue cleanup patches functionality changed Changes made remove unused imports remove unused methods fix JavaDoc errors tighter encapsulation removal unused variables appropriate
shutdown command takes least seconds broken two parts seconds first sleep shutdown request first ping see server shutdown second time trying obtain socket order perform ping see server shutdown socket creation fails correctly takes time socket creation time avoided socket used send shutdown request sleep time could reduced sleeping finer granularity long time modern processor
jira entry one tasks involved implementing existing SQLChar datatype default collation defined want support additional collation char datatypes based territory jira issue placeholder creating subclass SQLChar use passed Collator collation current use class territory based collation class used future kinds collations like etc
Add MBean application register change state JMX management JMX originally proposed mechanism configure replacing enhancing system properties tend static nature Thus somewhat ironic jmx enabled static system property propose add public mbean allows state JMX management changed bean automatically registered false instead registered application believe could occur time JMX could enabled running application possibly remote client standard Mbean amp ManagementMBean would operations amp attribute public boolean isManagementActive public void startManagement public void stopManagement booted within jvm operations would true register mbean implements ManagementMBean allow dynamic control visibility mbeans
following methods introduced interface part JDBC need implemented Clob getCharacterStream long pos long length Blob getBinaryStream long pos long length
Seen intermittently Linux since Seen Solaris lt signature gt ejbql Output line 454 expected lt 91 93 gt lt 91 93 gt lt gt lt signature gt floattypes Output line 1823 expected lt 91 93 gt lt 91 93 gt lt gt
moved J2SE used improve error reporting stated initial commit backed see Set couple locations JDBC level setup nested SQLExceptions means automatically stack trace database failed start includes reason failure rather see next exception great help running JUnit tests getting failures start database initial commit backed broke numerous tests JDK author indicated time investigate patch caused failures running tests Java SE
BackingStoreHashtable uses Vector Hashtable need synchronization provided classes think Replacing ArrayList HashMap could improve performance kinds operations
process converting test realized needed way run ij tests would work multiple connections made IjTestCase runs script ij main method redirects output file compares file canon Attaching patch issue test creates several databases run JUnit wrappers ij tests cleaning get cleaned later automatically
one ground works getting different kinds collations working character string types information project found Basically types DTD associated character string types DTDs valid values collation derivation collation type data types 2 fields apply ignored SQL spec talks character string types collation type collation derivation associated SQL spec Section Comparison character strings collation derivation says explicit implicit means valid collation type associated charcter string type collation derivation none means collation type established character string type 1 Collation derivation explicit COLLATE clause used character string type possibility planning support SQL COLLATE clause release 2 Collation derivation implicit collation determined COLLATE clause eg CREATE TABLE t1 c11 char 4 c11 collation USER character set Another eg TRIM c11 result character string TRIM operation collation operand c11 3 Collation derivation none aggregate methods dealing character strings different collations Section Data types results aggregations Syntax Rule 3aii
Persistent user defined character columns get added CREATE TABLE ALTER TABLE statements 2 statements set collation type character columns value collation type schema belong collation type get saved SYSCOLUMNS also saved metadata maintained Store
collation char datatypes different depending kind collation requested user database create time optional JDBC url attribute COLLATION collation type associated DTD determine kind DVD needs generated Note irrespective collation used format id char datatypes remain order support behavior generating base DVD collation sensitive DVD character datatypes need add new api StringDataValue look follows Gets either base classes subclasses Whether method returns base class subclass depends value RuleBasedCollator RuleBasedCollator null object returned would baseclass otherwise would subcalss public StringDataValue getValue RuleBasedCollator collatorForComparison
Add new api DVF make Locale object available DVF new api DVF get called boot method BasicDatabase BasicDatabase finished booting DVF Locale either Locale obtained territory attribute supplied user JDBC url database create time user provide territory attribute database create time set default JVM locale Locale object used DVF construct Collator object user requested territory based collation new api look like following void setLocale Locale localeOfTheDatabase
Provide new interface called getInstanceUsingFormatIdAndCollationType formatId collationType DVF Store call interface create empty DVD objects load DVD objects using readExternal performance efficiency Store needs base DVD subsequent needs call rather calling work required
performance reading modified Clobs poor demonstrated running test program selecting 10 MB Clob getting contents using getSubString unmodified Clob StoreStreamClob 300 ms modified Clob TemporaryClob 000 ms case Clob modified changing first character number subtasks created handle various issues related performance code cleanup brief overview see
Currently needs check 2 DTDs comparable calls method method move DTD consider collation information deciding 2 DTDs comparable collation information available TypeCompiler available DTD level information found important info thread copied gt think suggesting move comparable method gt TypeCompiler DataTypeDescriptor altogether gt existing code use TypeCompiler decide 2 types gt compared call method DTD determine gt comparability might cleaner stuffing collation information gt CharTypeCompiler wondering comparable gt defined DTD start go TypeCompiler gt functionality TypeCompiler provide DTD gt words understand connection TypeCompiler DTD gt fit together TypeCompiler provides functionality DTD instead DTD TypeCompiler Ignoring compiler aspect moment two components DataTypeDescriptor underlying SQL type INTEGER CHAR VARCHAR XML etc represented TypeId attributes descriptor nullablity length precision scale collation Thus DTD TypeId attributes functionality applicable type regardless specific DTD attributes thus methods functionality declared TypeId instead DTD functionality hand needs attribute information well say display length type function amp scale underlying SQL type collation changes moved comparable check reliant SQL type TypeId dependent type attributes collation type Thus original location comparable method made sense split due early plan version technology never happened demand One benefits SQL engine ability execute arbitrary queries would available execute version Code cleanup could done probably would decrease footrprint HTH Dan
Currently AssertFailure implements chaining exceptions use chaining mechanism provided JDK
places code used wrap unexpected exceptions underlying exception linked assert exception Therefore original stack trace possibly message text lost THROWASSERT Throwable THROWASSERT String THROWABLE used instead cases
Currently generate various SQL character types DVDs default collation Starting look collation type DTD deciding kind DVD gets generated SQL character types collation type character type terriotry based collation generate rather CollatorSQLxxx DVDs territory based collator associated hence collation order DVDs different DVDs default collation
would good dumped error printed parameters failed statement Currently default behaviour statement text print Users set want see parameters would useful errors included parameters well statement text reproduce put run script connect jdbc wombat create table int prepare p insert values execute p using values 1 execute p using values 10000000000000000000000000000000000000000000
adding new feature allow character string types territory based collation except persistent character string type columns system schema 2 character types compared collation type associated throw exception Currently codeline exception thrown something like ERROR 42818 Comparisons VARCHAR CHAR supported error message misleading error really collation mismatch fix following error indicates real reason behind exception eg sql ij gt connect nodb ij gt select tablename T1 ERROR 42818 Comparisons VARCHAR CHAR supported
Performance problems reported resolved updating cardinality statistics used optimizer Currently time statistics guaranteed index first created fully populated table easily accomplished existing table using command alter table lt gt compress 91 sequential 93 Compress table intensive task better way achieve would parser support update statistics command update fashion
still untested unused code relating implementation Nationa Char type current code removed believe interesting functionality associated provided territory based collation ever implements National Char type differently existing code collation tied National Char type believe future National char type might maintain separate type id compatibility jdbc interface actual implmentation code char types Collating national char type supported exactly way regular char types anyone really intested national char code history always available svn consistent version available looking codelines would propose removal code take place trunk backported released codeline
Add procedure amp function set get user connection authorization full access defined Based upon existing UserUtility class exposing single procedure sets permission avoid appearance procedure adds user VARCHAR 128 USERNAME VARCHAR 8 Valid values FULL Add user list full access users database database property READONLY Add user list users database database property NULL remove user list permissions reverting default permission VARCHAR 128 USERNAME RETURNS VARCHAR 8 Gets current connection access permissions user factors default connection mode Return either FULL READONLY NULL means connection attempt user denied user entry set noAccess names connection permissions match existing names use
Sun Java higher includes Xalan find moved package able detect use classes find Xalan standard package classpath would make easier many users start using XML features See also discussion thread lt URL gt
Emptying statement cache potentially useful diagnostic capabaility tested StatementPlanCacheTest However current functionality useable creating user procedure maps directly code disabled addition functionality control database owner become automatic SQL Authorization mode system procedure
fix place current implementation ClobUpdateableReader fail patch preparation mentioned issue also removed internal package private methods EmbedClob replaced single one Instead writing methods forwards calls underlying InternalClob method getInternalClob return internal clob seems place since method getByteLength belong EmbedClob also comes warning using reference internal clob object requires caller take care Second isWritable belong EmbedClob either Clob always writable unless However internal clob representation may case EmbedClob must clone content create writable representation fix leaves handling implementation details InternalClob
spec attached describes allow policy file dynamically reloaded server running add getPolicy permission Basic policy add system procedure reloads policy file JIRA tracks work
Currently StoreStreamClob reads whole Clob stream including decoding find length also second time length asked StoreStreamClob internal Clob representation Clobs soon user updates Clob transferred modifiable Clob representation determined safe cache length bytes characters store stream improve performance reduce load certain Clob operations locking mechanism used Clobs must analyzed obtained Clob object lock place stops others changing content isolation levels scrollable result sets streamed content store changed us thus invalidate cached length
plan following changes UTF8Reader Improve error reporting hitting UTF8 decoding error currently UTFDataFormatException message might also lead deleting one helper method generating exception one message Improve error reporting trying use reader closed currently IOException message Remove trailing spaces add newlines Replace tabs file spaces last point discussed arguments file mix tabs spaces still tabs Spaces method indentation want get fixed branch cut makes easier port fixes make see likely major fixes class branch volunteer Since much else Clob infrastructure changed recently seems like good time Please raise concern soon possible want veto changes plan commit tomorrow
Rename UpdateableBlobStream UpdatableBlobStream Also rename corresponding test classes affected rename
Network Client connect database retrieve error message print message tokens token separators log location would good least message could formatted present better message user without characters reproduce try database shutdown database shutdown client retrieve actual message server therefore prints tokens Start network server java start java ij version ij gt connect jdbc ij gt connect jdbc ERROR 08006 DERBY SQL error SQLCODE SQLSTATE 08006 SQLERRMC wombat shutdown server log ij gt Note actual offending characters replaced output bug break Jira XML retrieval
time leaf node visited index scan scan protection row locked unlocked lock operation unlock operation allocate new RecordId object representing scan protection row unlock operation additionally allocates PageKey object RecordId Since scan protection handle created identical seen equals time created page would make sense cache BasePage need allocate protection handle page long stays page cache would save three object allocations per lookup via index
time transaction committed aborted goes stack statement contexts invokes resetSavePoint Instead traversing list CtxStack object directly fetches view list Since lifetime CtxStack object list within span multiple transactions view needs created first time called object
indications buffer manager bottleneck types load instance Anders Morken wrote comment separate table index thread remove latch contention lock waits equation found caused 5 times contention synchronization might indicator apply next push would interesting see scalability performance buffer manager exploits concurrency utilities added Java SE 5
implementations ArrayInputStream identical corresponding ObjectInput methods Since ArrayInputStream implements ObjectInput readExternalFromArray could cases forwarded calls readExternal instead duplicating code default forwarding implementation readExternalFromArray could placed existing implementations except optimizations ArrayInputStream could removed
query optimizer usually makes best choice join order access path default join strategy ususally works best However cases user may want override optimizer default values Providing support optimizer overrides allow users optimizer queries
uses byte array buffer Wrapping array advantages instance utility methods encoding primitive types byte array could used instead manually encoding values allows us encode strings directly buffer using CharsetEncoder without expensive String encoding intermediate step using utility class code becomes easier maintain Also ByteBuffer allows us access backing byte array without going ByteBuffer interface still possibility modify byte array directly cases convenient
investigate whether anything SQL execution layer prevented scaling machine wrote test continuously executed VALUES 1 using PreparedStatement ran test machine 8 CPUs expected throughput proportional number concurrent clients 8 clients number CPUs However throughput small increase 1 2 clients adding clients increase throughput Looking test profiler seems like threads spending lot time waiting enter synchronization blocks synchronized GenericPreparedStatement object changed test slightly appending comment unique thread id VALUES 1 statement means threads still work thread got plan GenericPreparedStatement object since statement cache regard SQL text strings identical made change test scaled less perfectly 8 concurrent threads try find way make scalability regardless whether threads share plan
Language returns ResultDescription tree ie results passed application thus attribute plan activation ResultDescription already available plan activation method ResultSet lead assumption ResultDescription specific ResultSet shape results joins projection Note main implementation method calls
Varargs added Java 5 would nice let invoke function bound method variable length argument list Reference Guide states small number restrictions methods invoked functions must public static arguments long datatypes see reason able resolve invoke functions bound methods suffer limitations variable argument lists
following code protected final DataValueDescriptor getColumnFromRow int rsNumber int colId throws StandardException row 91 rsNumber 93 null actually happens attempts prefetch invariant values cache fails deeply nested joins See Beetle 4736 4880 return null return row 91 rsNumber 93 colId investigation came conclusion statement longer necessary fact makes diagnosing problems harder delaying point data structure problems exposed errors code JIRA issue requests code evaluated determine whether truly necessary necessary suggests removed result simpler clearer code
page cache often memory footprint much larger pageSize pageCacheSize One large contributor footprint array StoredPageHeader objects BasePage memory consumed objects large sometimes even larger byte arrays containing raw page data See instance Reducing size StoredPageHeader objects could therefore reduce memory footprint significantly especially page cache large contains many pages tables small records indices
LIKE clause territory based characters implemented correctly based SQL standards object String CollationElementIterator creations introduced cut following Knut simple solution copying solution implement solution improve performance LIKE territory based characters copied Another simple way cut string allocations think could express checkEquality like val 91 vLoc 93 pat 91 pLoc 93 character two strings consisting single character must equal regardless territory return true else collator null character must unequal return false String s1 new String val vLoc 1 String s1 new String pat pLoc 1 return s1 s2 0 would allocate new objects characters equal
Proposal enhance DDL User Management See proposal spec attached JIRA Abstract feature aims improving way users managed providing intuitive familiar DDL interface Currently users defined system database level Users created system level defined via JVM system properties file users created database level defined via call system procedure sets database property Defining user system level convenient practical development phase EOD application However user password encrypted consequently appears clear file Hence application going production whether embedded preferable create users database level password encrypted real ANSI SQL standard managing users SQL providing intuitive known interface ease User management database level well adoption
working roles notice max size 30 user ids authorization identifiers check performed parser private void checkAuthorizationLength String authorization checkIdentifierLengthLimit authorization 30 checked think fundamental reasons lift DB2 restriction authorization identifiers would max limit identifiers 128 Currently limit 30 enforced grantees However CREATE SCHEMA statement clause AUTHORIZATION lt authorization identifier gt allows specifying schema owner subject restriction also reflected reference documentation system tables Column Name Type Length Nullability Contents AUTHORIZATIONID VARCHAR 128 false authorization identifier owner schema Column Name Type Length Nullability Contents GRANTEE VARCHAR 30 False authorization ID user privilege granted Furthermore limit enforced authorizer code AuthorizationServiceBase authenticate also reflected metadata EmbedDatabaseMetaData getMaxUserNameLength think would good harmonize two different limits authorization identifier change limit 128
type classes save copy value converted String complicates code amp increases memory use little value cases cached value never used type scan String value discarded moving next row cases applications call getString twice column code historical basis fact types used represented object conversion String slow conversion types String simple addition think getString sometimes return form value set format cached String set format standard format believe incorrect
reason avoid rather substantial performance hit observed client driver used together appserver uses connection pooling two problems 1 connection pool compare isolation level stored connection value returned every time someone requests new connection pool 2 users connection pool ab use avoid keep track current connection time query needs executed call connection pool getConnection method made Getting connection connection pool like also means new PreparedStatement must prepared time net result query results following sequence getConnection getTransactionIsolation gt roundtrip lookup server statement cache prepareStatment gt roundtrip lookup server statement cache executeQuery gt roundtrip Arguably user error suggesting kindly informed works fine datbases PostgreSQL ORACLE reason works databases statement caching driver tried implement simple statement cache client driver caching isolation level see changes observe marked performance improvement running appserver load proper statment cache implemented without knowing current schema current schema changed since statement prepared longer valid must evicted cache problem caching isolation level current schema driver change server without client detecting SQL XA possibly stored procedures think problem overcome information would like cache messages going back client done utilizing EXCSQLSET DRDA command According DRDA spec v4 volume 3 page possible add one SQLSTT objects SQLCARD reply think would possible cache additional session information becomes relevant would also possible use EXCSQLSET batch session state changes going client server
explicit mechanisms start network server make mention install default security manager policy least NetworkServerControl javadoc summary start command command line main method start method start mechanism clearly state install install default security manager policy starts commands java java server start look see document default policy sure documented
part researching came conclusion trim method longer used could removed appears calls method switched call ansiTrim instead Hopefully requires removing code running tests verify nothing broken
trying get run phoneME advanced platform
Add remaining JDBC bits appear Java 7 javadoc addition JDBC bits visible Java 7 javadoc couple items appear JDBC Maintenance Review spec spec published JCP website attach functional spec remaining bits
hash values returned constructed performing bitwise xor 32 least significant bits record number page number container id segment id Since values tend relatively small positive integers hash values also tend clustered small range leads higher frequency hash collisions lock table makes hash tables work less efficiently thereby reduces performance example simple join load test client attached uses two tables TENKTUP ONEKTUP 10000 rows 1000 rows respectively RecordIds 11000 rows map less 900 distinct hash codes
Minor issue code public void forgetContext boolean mayStillRun cancel mayStillRun synchronized statementContext null mayStillRun cancel somewhat confusing see javadoc return value could indicate task may still run Less confusing code could public void forgetContext synchronized statementContext null cancel
asynchronous replication functionality writes information log would good improve following ways 1 startSlave stopSlave stack traces written twice log one obviously enough 2 possible configure replication messages written log followed stack trace cause 3 logged messages timestamp
CompilerContext saves isolation level LanguageConnectionContext LCC pushed restores popped However mechanism isolation level change compilation Isolation level changed SET ISOLATION SQL statement
support entire range valid finite values Java primitive types columns SQL type DOUBLE REAL appears limitation introduced compatibility DB2 requests lift restriction restriction enforced methods normalizeREAL normalizeDOUBLE
client driver code caching connect bytes used unused code clutters rest code makes harder understand Secondly variable used determine cached connect bytes used public someone historic information feature would nice could add information Jira
replication source code currently package services package intended modules Since replication code highly integrated store modules replication code moved See discussion
Stop running jdbc40 tests old test framework Tests old jdbc40 test suite run derbyall test suite even tests converted Junit run part Junit test suite Rewrite JUnit test test rewritten JUnit test line newly created test system one last tests still run deprecated directory wrapper class Investigate run client investigating noticed largeData suite run client comment says excluding since relevant clients excluding run network server curr ently lobs materialized test tests 2G lobs see issues Perhaps issues fixed test run client Perhaps separate suite embedded test takes 10 hours run Convert JUnit Convert JUnit testcase Convert JUnit
One side effect toString warning would change format starting SQLWarning match warnings created network client side See comments well possible correct package SQLWarningFactory Note generateCsSQLWarning removed seem used Note Also SQLWarningFactory would extend
additional system permissions proposed wonder makes sense change style names amp actions SystemPermission Today shutdown name proposed potential future shutdownEngine shutdownServer actions proposing names jmxControl serverControl engineControl etc also actions Looking standard Permission class seems name meant represent object permission applies action represent actions object Thus would seem make sense consistent Permissions monitor shutdown monitor shutdown
Dan suggested Setting NormalizeResultSetNode spread three locations class little almost acting like C struct genNormalizeResultSetNode method copyLengthsAndTypesToSource good implementation would logic create NormalizeResultSetNode NormalizeResultSetNode Since ResultColumnList original ResultSetNode correctly describes desired outcome clear NormalizeResultSetNode refer list use processing may chance would cause recursion point NormalizeResultSetNode would think needed wrapped NormalizeResultSetNode since types columns expression match handled regular ResultSetNode think moving setup NormalizeResultSetNode class inputs ResultSetNode wrap would help clear code especially comments added indicating certain actions taken separating task separate issue worked independently
Jdk introduced used print thread dump programatically test kills testers reaches deadlock testers complete would helpful case get thread dump automatically code could enabled jdk higher
DrdaStreamOutBufferSize attribute currently type String value attribute describes size buffer streaming server client property handled integer int DDMWriter class Network Server type changed int functional specification 91 1 93 since reason found String Similar attributes DrdaMaxThreads return type int may useful JMX client know value int instead arbitrary string hence change 91 1 93
Currently network server support following security mechanisms 1 USRIDONL userid 2 USRIDPWD clear text userid password 3 EUSRIDPWD encrypted userid password Thus 3 encrypted userid password security mechanism secure respect sent across wire Currently way setup network server ensure accepts connections coming certain security mechanism seems reasonable amp useful server want accept connections clients particular security mechanism lets say encrypted reject usridpwd ie clear text userid password jira add support adding property enable server able accept connections clients certain security mechanism actually couldnt find rank given security mechanisms drda spec maybe property setting minimum security mechanism accepted server would appropriate
Army attached great explaining NormalizeResultSetNode works incorporated NormalizeResultSetNode javadoc
would good stack traces threads dump assertion occurs JVM support
Knut Anders raised issue whether still need jar file built without jar file run regression tests Java 5 passed cleanly environments believe remove jar file added revision 395643 order compile xml support longer support platform
would good simplify build whole product could built checked repository step toward goal would good able build jsr169 support without download proprietary libraries
Network Server console messages print time stamp Methods need changed consoleMessage onsolePropertyMessage consoleExceptionPrintTrace
API specification TableFunctions provide information implementer TableFunction details query example defined table function named MyFunction columns b amp c b bind table function properly using CREATE FUNCTION SQL User executes following SQL select b table MyFunction c 123 Without passing column list clause arguments table function implementation know needs two three columns rows c 123 TableFunctions built integrate data cost query prohibitive would better information regarding columns select restrictions clause could passed developer
likely cause error sort page level corruption corrupted format id field page information data page may help diagnose going instance page dump may give insight ERROR XSDB1 Unknown page format page Page 122 Container 0 1248 Caused ERROR XBM0U class registered identifier 23364 begin nested exception level 1 ERROR XBM0U class registered identifier 23364 end nested exception level 1
thread mentioned RAFContainer4 calls padFile creating container Since padFile uses old calls rest RAFContainer4 uses NIO could possibly cause similar issues seen Although verified problem try avoid mixing old NIO safe side
Improve text associated ERROR XSDB3 Container information change written 103 80 would nice know database container least possibly info may changed Maybe dumps track overlapping errors page 0 stack trace reported part encountered back ground thread GMT Thread 91 93 Cleanup action ERROR XSDB3 Container information change written 103
creating test database external USB drive formatted contains tables quite large binary objects conjunction Hibernate got rather cryptic error message Looks rather scary WARN SQL Error 40000 SQLState 08006 ERROR network protocol error encountered connection terminated requested command encountered unarchitected condition architected message ERROR Could synchronize database state session could insert 91 proteinChainMoleculeBinaryData 93 Initially didnt even occur may due using FAT32 drive eventually figured table file got operating FAT32 limit file KB log revealing still incorrect error message ERROR XSDG1 Page Page 131071 Container 0 2384 could written disk please check disk full Caused enough space disk Native Method error still strictly speaking incorrect disk far full created file big disk type error least closer truth would useful information client display rather rather scary looking message getting
Currently SQL length function materializes entire lob memory public final int getLength throws StandardException stream null streamValueLength return streamValueLength return getBytes null 0 getBytes actually doubly bad call getBytes twice materialize twice would good read length stream available otherwise stream value get length rather materializing memory reproduce run attached repro java LengthLargeLob gives memory exception Caused Java heap space
Adding new replication state tests Due plus refactoring cleanup
class contains significant amount test code code moved unit test reduce footprint product jars ensure code tested regression tests test code located methods checkInt checkLong main
docs say REVOKE EXECUTE RESTRICT fail dependent constraint RESTRICT clause specifies EXECUTE privilege revoked specified routine used view trigger constraint privilege revoked owner view trigger constraint Revoking privilege correctly restricted possibly wrong reason
network server needs SocketPermission listen port listens permission granted basic server policy installed default cause problems cases since JVM default policy grants code bases SocketPermission listen range ports network server port within range Still network server rely fact possible run network server port ports happen range given carte blanche platform default policy network server however able run ports basic policy currently custom policy security manager disabled default policy make permission explicit
uses read process whole Blob length encoded head stream Using skip instead read lead better performance also plan make minor cleanups issue JavaDoc rename variable
max length VARBINARY VARCHAR 32 672 bytes characters see working LOBs represented locators using read buffer larger max value causes server process far data necessary Say read buffer 33 000 bytes bytes requested client requests ends Assume stream position 64 000 want read following happens BLOBGETBYTES instructs EmbedBlob read 33 000 bytes advancing stream position 97 000 b 33 000 bytes send 32 672 rest data 328 bytes discarded c client receives 32 672 bytes recalculates position length arguments sends another request BLOBGETBYTES locator 96672 328 executed EmbedBlob detects stream position advanced far resets stream position zero position 96 672 reached e remaining 328 bytes sent client issue deals points b avoiding need reset stream Points e also problematic large number bytes going read say hundreds megabytes another issue unfortunate using 32 K 32 1024 buffer size almost worst case 32 768 32 672 96 bytes
contract somewhat difficult would even say broken See utility class created ensure use skip procedure throughout code base Suggested functionality long skipFully InputStream skips EOF returns number bytes skipped void skipFully InputStream long skips requested number bytes throws EOFException bytes stream know two different approaches skipping loop Verify EOF read call skip returns zero b Throw EOFException skip returns zero requested number bytes skipped related code Maybe class say StreamUtil could put package
Currently table contains column operations table throghs unsupported feature exception set schema iep set schema iep create table ntype int ct CLOB 1024 create table ntype1 bt BLOB 1024 int call iep ntype null null null ERROR XIE0B Column CT table type CLOB supported th e feature
LOBStreamControl throws three types exceptions IOException SQLException StandardException SQLException code LOBStreamControl level code SQLException thrown tedious handle SQLException StandardException higher levels propose replace SQLException StandardException LOBStreamControl purpose change consistency also results slightly less code higher levels
provided manual way update statisitcs discussion jira entry possibly optimizing cases need update statistics enter related comments jira entry reference Knut Anders Hatlen understood correctly unique indexes always date cardinality statistics cardinality row count case one possible optimization skip unique indexes called Mike Matrigali cardinality unique index 1 row count also complicated skipping unique indexes depends number columns index index multiple cardinalities calculated instance index columns B C actually 3 cardinalities calculated B B C agree calculation cardinality B C short circuited unique index Knut Anders Hatlen PM Mike looks cardinality number unique values think cardinality unique index equal row count full key right short circuit index know worth extra complexity short circuit B C case since scan entire index anyway unique index sounds like good idea though
method used one internal Clob implementation removed reduce complexity code volume method removed
fix committed code could performed remove workaround tests search string find remove logic prevent waiting table locks since new mechanism prevent waiting types locks
sometimes seen profiler unreasonably high amount CPU time spent network server running method used check active statement current transaction cursor name statement currently executed normally used executing statement cursor name None statements cursor name saw method always called network server executes statement network server assigns cursor name statement even cursor name set client side list open statements short method relatively cheap one uses ClientConnectionPoolDataSource JDBC statement cache list open statements however quite long lookupCursorActivation needs spend fair amount time iterating list comparing strings time spent looking duplicate names lookupCursorActivation actually wasted time called network server since network server assigns unique names statements executes even duplicate names client would good could reduce cost operation perhaps eliminate completely client use cursor names
Rick suggested would nice something allow inspection enabled roles cf view information schema SQL 2003 vol 11 section enclose patch suggestion via new VTI table syntactic sugar ij ij command show commit point may want handle general question information schemata another way say thee
ALTER TABLE ADD COLUMN used add identity column code handle identity columns disabled parser See thread code disabled DB2 compatibility Since DB2 compatibility goal see could
unique constraint violated insert statement throws SQLIntegrityConstraintViolationException error message contains particular constraint name table name distinguish cases various constraints instead throw subclass SQLIntegrityConstraintViolationException methods like getConstraintName getTableName See also
slave replication mode started encrypted database fails NPE hangs reason hang LogToFile initializeSlaveReplicationMode needs scan log find end encrypted databases scan uses RawStoreFactory decrypt stage LTF rawStoreFactory variable set solution may set variable LTF scanning log
store save useful length information Clobs allows length found without decoding whole data stream following thread raised issue information store also contains background information information store exact format still Currently two bytes set aside length information inadequate
use simple algorithm takes sum values array gives poor distribution hash values similar values higher probability mapping hash code higher bits used unless array long change methods use algorithm similar one used described lt URL gt may positive effect performance hash scans reduce likelihood collisions hash table
Inserting table function lot like importing file 1 limited visibility size external data source 2 user often trying import large data set import procedures assume always apply optimization importing file assumption seems reasonable whenever table function appears source stream INSERT
TemporaryClob save known length Clob situations following places code improved easier others TemporaryClob String ConChild b copyClobContent InternalClob long c copyClobContent InternalClob might additional places fix
order bundle popular linux distributions like Debian Ubuntu must possible build sources existing linux components replacing Felix jar corresponding sources move another step closer able bundle linux distributions
provided new stored procedure update statistics code work added AlterTableConstantAction name new method class updateStatistics Activation activation code copied existing unused class unused class removed code copied code AlterTableConstantAction updateStatistics gets compile transaction shown work updating statistics TransactionController tc javadoc LangaugeConnectionContext getTransactionCompile says following Get transaction controller use language connection context compile time TransactionController getTransactionCompile think using TransactionController tc work since compile phase rest code AlterTableConstantAction uses get transaction controller make changes use getTransactionExecute run existing tests make sure nothing breaks ran issue getTransactionExecute vs getTransactionCompile working provide way updating statistics trying run statistics inline duirn compile phase SELECT query ran exception statistics updated mode change AlterTableConstantAction use getTransactionExecute run mode exception Please let know anyone comments run existing tests failures go ahead commit change using getTransactionExecute rather getTransactionCompile AlterTableConstantAction updateStatistics
objects try declare function procedure argument whose type BLOB CLOB kinds arguments allowed SQL standard matching Java types See summary attached lift restriction allow functions procedures take large object arguments
SQL 2008 added new syntax support direct way limit returned set rows result set allows application retrieve rows otherwise larger result set similar popular LIMIT clauses use databases till SQL use function nested subquery achieve effect lt fetch first clause gt cf method rather indirect still efficient primarily intended OLAP functionality perhaps direct way achieve effect lt result offset clause gt via SQL Syntax cf SQL 2008 section lt result offset clause gt OFFSET lt n gt ROW ROWS lt fetch first clause gt FETCH FIRST NEXT 91 lt n gt 93 ROW ROWS lt n gt integer two clauses syntactically follow ORDER clause grammar Note ORDER new clauses allowed also subqueries new version SQL standard section propose include top level DERBY ORDER presently also allowed subqueries since SQL allow SQL 2008 either
change connection toString output integer correspond SESSIONID output identify type also meaning identifier prints Perhaps format appends default toString output sessionid information prints would informative efd552 SESSONID 2 Ultimately could expanded included diagnostic information efd552 XID 132 SESSIONID 5 DATABASE wombat DRDAID 7
javadoc BTreeLockingPolicy still talks scan locks although scan lock longer use javadoc updated reflects current state code
Network server currently reports start stop network server console output print associated timestamp would helpful start stop times network server recorded would need check console output
Currently system properties used runScript method raises issue allowing port used JUnit tests customized therefore blocking idea allow properties set either system properties Properties object passed runScript method Please share thoughts ideas may best approach
store stream Clob going modified written temporary area represented TemporaryClob transfer data done manner two reasons transfer complete Clob copy method operates byte level able save character length transfer parts Clob truncation first decode encoding find byte count transfer bytes intend following two changes 1 Add InternalClob 2 Add aware copy method LOBStreamControl complete Clob copied code like executed cachedCharLength cachedCharLength gt 0 use existing copy method best performance copy EOF else cachedCharLength parts Clob copied always use aware copy method also cheap range check cachedCharLength cachedCharLength gt 0 amp amp requestedLength gt cachedCharLength throw EOFException cachedCharLength requestedLength use existing copy method best performance copy EOF else cachedCharLength requestedLength Adding aware copy method started including comments first revision patch
quite instances public static fields appear intended constant final code would safer constant fields made final Patch follow problem fields following also ought fixed use accessor lookup values ditto
working found exception handled properly server shutdown code caused new instance server startup hang Resolved problem Connection close general 1 Make sure exception shutdown processing prevent remaining shutdown tasks like closing server socket occurring 2 Make sure exceptions occur shutdown processing reported console
SQL standard defines two ways specify join condition INNER JOIN OUTER JOIN clause USING clause currently accepts joins clause Internally code supports USING code enabled ease migration must also verify implementation adheres standard enable Since USING already reserved keyword parser enabling USING syntax cause compatibility issues existing queries
allowed ij gt create table t1 integer 0 rows ij gt create table t2 integer 0 rows ij gt create table t3 integer 0 rows ij gt insert t1 values 1 1 row ij gt insert t2 values 2 1 row ij gt insert t3 values 3 rows ij gt select t1 select t3 0 rows selected ij gt select t1 inner join t2 select t3 ERROR 42972 clause associated JOIN operator valid ij gt
SQL 2008 allows ORDER specified subqueries conjunction meaningful subqueries row ordering may formulated Cf MySQL LIMIT may used subqueries well Note currently allowed subqueries either
SQL 2008 specifies lt result offset clause gt lt fetch first clause gt may used subqueries Currently allows outer cursor level Cf also allowing ORDER subqueries extension portable useful SQL features F856 Nested lt fetch first clause gt lt query expression gt F857 lt fetch first clause gt lt query expression gt already present F858 lt fetch first clause gt subqueries F859 lt fetch first clause gt views F860 dynamic lt fetch first row count gt lt fetch first clause gt already present F861 lt result offset clause gt lt query expression gt already present F862 lt result offset clause gt subqueries F863 Nested lt result offset clause gt lt query expression gt F864 lt result offset clause gt views F865 dynamic lt offset row count gt lt result offset clause gt already present
Network Server started PrintWriter specified console output automatically flush output starting server confusing console output shows activity Users currently need specify PrintWriter autoflush starterWriter new PrintWriter new FileOutputStream new File true derbyServer new NetworkServerControl starterWriter repro see change following line program autoflush follows starterWriter new PrintWriter new FileOutputStream new File false
number parameters routine arbitrarily limited 90 limit causing difficulties users see ought safe lift limit Changes need made CreateAliasNode corresponding test
would nice able tell compiler use formatters abstract syntax trees instance would nice able plug AST printers attached including tree grapher written Kay Rpke
lack boolean data type forces use expressions like 1 lt gt 1 express true false Generated SQL statements also tend use expressions queries many useful optimizations boolean instance ProjectRestrictNode PredicateList able eliminate predicates cases entire ProjectRestrictNode predicate contains constant true false values However parsing compilation expressions like rewritten TRUE get benefit boolean optimization code leads complex possibly less efficient byte code generated statements Also boolean constants assigned selectivity false true since always match rows false rows true expression however get selectivity operator means selectivity assigned operators different selectivity 2 lt 3 selectivity even though actual selectivity expression TRUE namely leads oddities like optimizer choosing different plan change 2 lt 3 clause See example could go query tree replace occurrences comparisons constant values boolean constant bind time queries would end simpler byte code selectivity passed optimizer would accurate possibly resulting better plan chosen
Currently walks tree always calling visit parent calls visit children Although fine cases use cases visiting nodes would better One example mentioned visitor posted looks binary comparison operators checks whether operands constants operator replaced boolean constant Take expression example 1 lt 2 2 gt 1 query tree looks like lt gt 1 2 2 1 walk tree said visitor node constant operands visited lt gt operators constant operands replaced constant TRUE means expression 1 lt 2 2 gt 1 rewritten far transformation goes tree processed would start lt gt operators replace TRUE query tree would therefore transformed intermediate form operator visited TRUE TRUE end result visiting operator visited yet Since operands operator constants visitor perform yet another transformation tree simplified ends TRUE
Dyre Tjeldvoll posted results indicated types load might cause contention shared long suggested replaced platforms support splitting issue two possible improvements reported addressed independently
BUILTIN authentication scheme protects passwords hashing algorithm would nice way specify different algorithm users take advantage new stronger algorithms provided JCE provider desired issue tracks response security vulnerability Marcell Major identified See
first checks Hashtable trans contains transaction id one added add nothing transaction new TransactionTableEntry created put Hashtable believe never called transaction already added table case point checking Hashtable first Instead could create new TransactionTableEntry add unconditionally would reduce number synchronized Hashtable calls could improve performance scenarios like one described
function allow import data external resources general process CSV files created various tools one exception header line accepted standard tools include header line CSV file column names convention supported Excel many tools Request extend related procedures include extra indicator number header lines ignored extra bonus help accept column names instead column indexes COLUMNINDEXES arguments possible indicate COLUMNINDEXES feature make significantly easier handle cases external input files extended include additional columns
usage method InputStream stream int length unclear intended use seems pass known length input stream set setBinaryStream seems two distinct cases logical length stream known logical length stream known Using length known seems established pattern
increased use streams represent data values cloning facilities needs improved Unless get pushback proceed producing patches reach following goals move functionality provided CloneableObject DataValueDescriptor classes implementing CloneableObject also implements DataValueDescriptor introduce cloning methods cloneValue cloneState cloneHolder DataValueDescriptor see description Note return usable DVD ears better names clone methods another suggestion mentioned cloneDeep cloneHalfDeep cloneShallow NOTE See comment method names changed course development cloneValue lt deep gt new method functionality present combined calls DVD public interface DVD obtained cloneValue independent DVDs state store data value materialized cloneState lt halfDeep gt DVD obtained cloneState independent DVDs may depend state store due references store streams data value materialized value represented stream believes materializing value appropriate keeping stream representation cloneHolder lt shallow gt DVD obtained cloneHolder dependent original DVD clones made cloneHolder one DVDs changes state affected also dependent state store references store streams data value never materialized due cloneHolder invoked many data types cloneState cloneHolder forward cloneValue cloneState used cloneValue currently required sorter cloneHolder required performance reasons maybe avoid OOME DVDs pass temporary holders BackingStoreHashtable TemporaryRowHolderImpl gone usages cloneState see replaced another ability clone store streams added Mike patch attached New method names turned using two methods sufficient cloneHolder lt shallow gt cloneValue boolean forceMaterialization lt halfDeep deep gt Basically cloneValue false equals cloneState cloneValue true equals cloneValue
order trigger action access values triggering table CREATE TRIGGER use REFERENCING clause Without REFERENCING clause old new values triggering table accessed trigger action Based improve memory utilization keeping old new values REFERENCING clause missing good see code already optimization introducing optimization definitely useful triggering table could LOB columns
pattern use following piece code determine data value stream null Since stream mutable state obtaining reference check null several reasons may throw exception data types supporting streams stream reference leaked unfortunately required guarantee something stream state instance descriptor sync stream cases investigate state stream unnecessary work makes harder write debug code stream reference obtained data value descriptor plan introduce method returning boolean addition obvious check stream variable also used instruct treat certain data values even though underlying value currently stream One example CHAR VARCHAR whose maximum lengths small always materialized avoid added complexity coming streams stream state isolation levels extra lock keep stream stable cloning
fixed users upgrading JVM seeing error dual boot course good thing however time need diagnose dual boot coming sometimes harder one might think complex system legacy code would helpful property could set would print stack trace boot attempt even successful help diagnose application error maybe
found database application prevents startup due corrupted driver reports database exist even though app tries create database using URL fails think happened due app killed Task Manager creating database database saved reproduce problem sure attach yet
CoalesceFunctionNode manually iterates argumentsList ValueNodeList acceptChildren preprocess remapColumnReferencesToExpressions isEquivalent ValueNodeList helper methods first three helper methods used instead simplify code helper method isEquivalent since similar code also found isEquivalent methods BinaryListOperatorNode ConditionalNode add new helper use classes
Curretnly way hide data database structure embedded end user One way accomplish requirement follows 1 Create encrypted database data protected 2 Enable authentication sql authorization database 3 Create two users dbUser dbOwner 4 Store application logic stored procedure databse dbUser know tables accecced application logic thus hiding table structure 5 Revoke select permission dbUser describe tables thus protecting table structures 6 Give Execute permissions stored procedures dbUser steps ensure data data structure hidden application delivered end user problem user select permission stored procedures execute requesting following enhancement dbOwner given Execure permission stored procecure dbUser allow stored procedure execute even dbUser select permission otherwords dbUser calls stored procedure database use dbOwners authorization execute stored procedure rather dbUsers may implemented creating new permission called RunAsDbOwner DbOwner grant permission dbUser execute stored procedure RunAsDbOwner implemented applications created truely hide database structure data end users Database behave blackbox data exposed stored procedures
int DataValueDescriptor boolean boolean converts values strings order check whether null isNull method used instead prevent unnecessary conversion strings See thread
inserting character values converts Java char encoding user stream read resulting bytes conversion placed translation buffer default size buffer 32 KB inserting lot short values pressure Java garbage collector unnecessary high also causes somewhat higher CPU usage effect issue easily reduced sizing buffer appropriate cases
contains code twice waitForLock throw lock timeout error throw second occurrence code never end throwing exception since waitForLock guaranteed true identical check couple lines Judging similar method lockPositionForRead probably first check removed latch page released exception thrown Also method always called forInsert parameter removed also suspect method work correctly ever used insert operation since calls latchPage RowPosition unlatch page row found page assume row inserted exist yet
looking also looked query validate changes also worked variant problem inspection query trees bind phase found one instance pair tablenumber columnnumber column reference wrong Although seem impact query result note something probably investiate may symptom underlying problem potential future problems query looks like select b3 b3 join bvw join b4 42 underlying DDL create table b2 c1 int c2 int c3 char 1 c4 int c5 int c6 int create table b4 c7 int c4 int c6 int create table b3 c8 int c9 int c5 int c6 int create table b c1 int c2 int c3 char 1 c4 int c5 int c6 int create view bvw c5 c1 c2 c3 c4 select c5 c1 c2 c3 c4 b2 union select c5 c1 c2 c3 c4 b create view bvw2 c1 c2 c3 c4 c5 bind phase join clause following entry column reference tableNumber 1 columnNumber 6 problem node tablenumber 1 bvw view subquery union 5 resulting columns 6 must wrong Although view participant tables b b2 six column view case C1 column 2 view column 2 two union selects b b2 C1 however column 6 join node resulting select b3 b3 join bvw correct table number would 5 1 would seem table number bound bvw view result set column number bound innermost join node result set looks worrying See attached full dump query tree bind phase sourceResultSet 12789d2 correlation Name BVW null tableNumber 1 lt Note level 0 resultSetNumber 0 referencedTableMap null statementResultSet false resultColumns c943d1 indexRow false orderBySelect 0 91 0 93 d3c6a3 truncated 91 1 93 18352d8 exposedName C1 name C1 tableName null isDefaultColumn false wasDefaultColumn false isNameGenerated false sourceTableName B2 type INTEGER columnDescriptor null isGenerated false isGeneratedForUnmatchedColumnInInsert false isGroupingColumn false isReferenced true isRedundant false virtualColumnId 2 resultSetNumber dataTypeServices INTEGER expression b40ec4 dataTypeServices null sourceColumn 1d95da8 truncated sourceResultSet 14d7745 truncated 91 2 93 13576a2 exposedName C2 name C2 tableName null isDefaultColumn false wasDefaultColumn false isNameGenerated false sourceTableName B2 type INTEGER columnDescriptor null isGenerated false isGeneratedForUnmatchedColumnInInsert false isGroupingColumn false isReferenced true isRedundant false virtualColumnId 3 resultSetNumber dataTypeServices INTEGER expression ff8c74 dataTypeServices null sourceColumn 61736e truncated sourceResultSet 14d7745 truncated 91 3 93 15e2ccd exposedName C3 name C3 tableName null isDefaultColumn false wasDefaultColumn false isNameGenerated false sourceTableName B2 type CHAR 1 columnDescriptor null isGenerated false isGeneratedForUnmatchedColumnInInsert false isGroupingColumn false isReferenced true isRedundant false virtualColumnId 4 resultSetNumber dataTypeServices CHAR 1 expression 1cf7491 dataTypeServices null sourceColumn 11946c2 truncated sourceResultSet 14d7745 truncated 91 4 93 lt highest column number 5 index edf730 exposedName C4 name C4 tableName null isDefaultColumn false wasDefaultColumn false isNameGenerated false sourceTableName B2 type INTEGER columnDescriptor null isGenerated false isGeneratedForUnmatchedColumnInInsert false isGroupingColumn false isReferenced true isRedundant false virtualColumnId 5 resultSetNumber dataTypeServices INTEGER expression ff94b1 dataTypeServices null sourceColumn 17a4989 truncated sourceResultSet 14d7745 truncated subquery 14d7745 truncated
Add mechanism system functions easily added Resolution functions check lt name gt function call SQL function qualified schema current schema function matching name additional resolution made using lt name gt Add table driven mechanism simple single argument functions could expanded future Add functions SYSFUN functions 91 0 93 FUNCTION name 91 1 93 RETURNS type 91 2 93 Java class 91 3 93 method name 91 4 93 parameter type single parameter private static final String ACOS DOUBLE acos DOUBLE ASIN DOUBLE asin DOUBLE ATAN DOUBLE atan DOUBLE COS DOUBLE cos DOUBLE SIN DOUBLE sin DOUBLE TAN DOUBLE tan DOUBLE DEGREES DOUBLE toDegrees DOUBLE RADIANS DOUBLE toRadians DOUBLE LN DOUBLE log DOUBLE EXP DOUBLE exp DOUBLE CEIL DOUBLE ceil DOUBLE CEILING DOUBLE ceil DOUBLE FLOOR DOUBLE floor DOUBLE
queries form lt column gt LIKE lt gt optimized index scans equivalent expression using concatenation lt column gt LIKE lt gt would result table scan Queries form lt column gt LIKE optimizable using internally generated parameter seem generate parameter concatenation strings string expressions well value calculated course limited cases result string expression calculated independent columns query sometimes possible work around manually adding x gt lt gt x lt lt gt condition
possible open connections several databases running ij currently possible copy data one DB one feature would allow copy data databases ij mostly DB agnostic ease JDBC compliant data source See
Currently whenever client driver used limit 255 bytes database name defined DRDA spec discussion list 91 1 93 91 2 93 whether limit raised due introduction new ACR allows characters characters take four bytes reduces limit characters dramatically easy change codepoint defines limit 91 1 93 work 91 2 93 91 1 93 91 2 93 http
preliminary platform testing 91 1 93 Kathey Dag Lily seen SysinfoCPCheckTest fail different Windows platforms XP Windows 7 run part suitesAll 91 1 93 Thanks Myrna points could relate
Often issue occurs one thing get retrieved often gets passed many layers reaches people supporting would helpful also included following help instruct customers change look log 1 location 2 location indicate error log redirection defined
Somewhat simplified release manager RM must currently perform following manual steps feed release note generate data needs Create manual JIRA filter select issues addressed release b Save filter result disk XML c XML parser able parse report Determine record JIRA release note attachment ids issues requiring release note using current version SOAP API steps b removed
JVMInfo contains code switch using based JVM version needed supported Java since introduced Java used instead old platforms Currently supported JDBC versions including small devices code longer needed
current mechanism deleting databases good enough proper one must added also important able delete databases since occupy valuable main memory discarded database longer needed intend implement mechanism using JDBC connection URL jdbc memory myDatabase 91 93 connection attempt throw exception case either request failed succeeded Reasons failure invalid user password lacking encryption attributes conflicting attributes time database owner allowed delete databases note way database creation
warnings see points Java 6 class libraries either set explicitly implicitly property setter 91 javac 93 warning 91 unchecked 93 unchecked conversion 91 javac 93 found 91 javac 93 required lt gt 91 javac 93 new StandardMBean bean beanInterface 91 javac 93 91 javac 93 warning 91 unchecked 93 unchecked method invocation lt gt StandardMBean lt gt applied 91 javac 93 new StandardMBean bean beanInterface 91 javac 93 91 javac 93 2 warnings 91 javac 93 warning 91 unchecked 93 unchecked call getMethod lt gt member raw type 91 javac 93 methodName new Class 91 javac 93 91 javac 93 warning 91 unchecked 93 unchecked call getMethod lt gt member raw type 91 javac 93 methodName new Class 91 javac 93 91 javac 93 warning 91 unchecked 93 unchecked call getConstructor lt gt member raw type 91 javac 93 new Class 91 javac 93 91 javac 93 warning 91 unchecked 93 unchecked call getMethod lt gt member raw type 91 javac 93 methodName new Class 91 javac 93 91 javac 93 4 warnings
Many private methods take activation sometimes number references obtained argument seems unnecessary clutters code argument passing boilerplate code variable hiding
Currently Embedded Driver supports Client Driver Client Driver enhanced match Embedded Driver need transfer timeout value client server preferably without separate loose thoughts client set timeout value statement prepend DRDA EXCSQLSTT command EXCSQLSET command contains timeout value conceptually SET STATEMENT TIMEOUT lt seconds gt mean need extend grammar Network Server needs understand DRDA EXCSQLSET command server side recognize SET STATEMENT TIMEOUT text parse timeout value remember coming EXCSQLSTT command invoke executeUpdate SET statement 91 see note 93 check timeout value set use setting timeout value Statement object calling
made possible use JIRA SOAP API fetch list issues fixed release However release manager manually create JIRA filter feed filter id tool Apache JIRA instance updated use JIRA Query Language JQL avoid manual step
automatic index statistics daemon default log means messages like ones written normal operation Wed Mar 02 CET 2011 Thread 91 main 93 istat APP update scheduled 91 stats 93 Wed Mar 02 CET 2011 Thread 91 main 93 istat APP generating index statistics Wed Mar 02 CET 2011 Thread 91 main 93 istat APP generation complete 509 ms Wed Mar 02 CET 2011 Thread 91 main 93 istat stopping daemon 91 err rej 93 Although messages may helpful diagnosing bugs may also source confusion since users probably expect logged default Also workloads large quantities log may produced take disk space Therefore think disable logging release instead instruct users experience problems enable logging manually property
sake observability debugging wild tracing logging runtime exceptions raised istat thread improved
web site describes layout log control file description agree format actually produced format examined using ControlFileReader tool attached description web site corrected
see could use instead byte array similar DDMWriter ByteBuffer provides helper methods allows us simplify code puts values buffer like putInt putLong may also first step way using CharsetEncoder encode strings without going via intermediate byte array see details
Users often bad advice desperation touch delete files log seg0 directories mostly log think would good new databases upgrade file created directories name like warn perils corrupting effects eliminate possibility salvage also encourage users make zip backup database directory jvm currently accessing trying anything database appears already corrupt Also point documentation encourage restore good backup empty directory database corrupt sure would help hurt
Network Server appears look Embedded Driver couple places order get connection actual database means network server operate environments whatever reason OK access embedded driver DriverManager general behavior unexpected possible directly load embedded driver observed issue checked relevant usages unchanged trunk
critical information sysinfo available boot message except operating system information OS name Windows XP OS architecture x86 OS version build 2600 Service Pack 3 would useful log operating system info well boot close filing issue last piece info needs added error log
ConcatenationOperatorNode generates bytecode ensures result object null calling method implements operator breaks pattern used operators ensures result object null inside method implements operator generated bytecode unnecessarily complicates code BinaryOperatorNode comments indicate current approach chosen prevent null check happening execution time generated bytecode perform null check execution time generating byte code real benefit writing Java code general implementing much possible execution time code Java code preferred implementing directly bytecode easier read debug Java code generated bytecode shared execution plans take memory
error reporting AssertFailure somewhat imprecise may also fail NPE testAssertFailureNoThreadDump ERROR Native Method
variant method never called replace true code handle replacement removed
JIRA add support DRDA Strong User ID Password Substitute Authentication USRSSBPWD scheme network driver layers Current DRDA network client driver supports encrypted EUSRIDPWD via use DH protocol however current Open Group DRDA specifications imposes small prime base generator values 256 bits prevents JCE used java cryptography providers typical minimum security requirements usually 1024 bits absolute minimum using DH protocol generate session key Strong User ID Password Substitute Authentication USRSSBPWD part DRDA specifications another alternative provide ciphered passwords across wire Support USRSSBPWD authentication scheme enable additional JCE used encrypted passwords required across wire USRSSBPWD authentication scheme specified network client user via securityMechanism property connection UR new property value defined order support new DRDA authentication scheme
DataDictionaryImpl CreateTriggerNode contain implementations bubble sort could replaced calls performance critical code used sorting vectors column references table nodes compile time much gain sorting Using benefits results less code implementation probably gone testing one
error reporting replication test deleting files initialize insufficient message printed console test continues run cause test fail appears different reason files
Currently allows users perfoms online backups using procedure backup progress update operations temporarily blocked read operations still proceed Blocking update operations real issue specifically client server environments user requests blocked long time backup progress server
tried running Oracle Java Embedded Client booting engine failed Caused seems happen recognizes Java platform whereas actually platform
classes Cursor NetCursor client driver contain many unused methods managing internal byte buffer methods removed
RDBMS support SQL standard statistics functions DB2 STDDEV VARIANE H2 HSQLDB Ingres MySQL Oracle Postgres SQL Server named STDEVP STDEV VARP VAR Sybase ASE Sybase SQL Anywhere SQLite would useful addition think even larger example list possible statistics aggregate functions listed Postgres documentation
various support situations seen problems JDBC metadata stored prepared statements trigger stored prepared statements need invalidated would nice way field stored procedure would make sense would good something available release branches
Since network clients besides Network Client tested supported since since protocol based client needs understand DRDA extensions deviations stored procedure usage think would good idea Network Server outright reject network clients Network Client would eliminate confusion front might aware DB2 Universal JDBC Driver DB2 Runtime Client supported would get clean reasonable error instead hitting various protocol errors Also would mean someone want add support network client future would least need add one two lines code AppRequester identify think would good thing think code change would hard biggest impact might anyone still runs tests JCC trunk would need disable tests separate issue Jayaram working complete remove JCC related code tests test infrastructure
two issues already seen boot issue 16 chance wrong bootPassword allow boot proceed since decoded key wrong boot fail password change issue similarly chance wrong bootPassword accepted trying change via bootPassword least algorithms check IV initialization vector addition digest latter case may lead data corruption cf discussion think risk fairly low though One would need execution permission change property SQL authorization used scenarios supplied existing password would correct since results bad would good reduce eliminate risk
opening large number databases parallel many threads get stuck long time FileMonitor reported thread synchronization FileMonitor needed monitor instance also used shared PrivilegedExceptionAction instance Since databases share one FileMonitor instance threads access methods serialized method created PrivilegedAction PrivilegedExceptionAction instance instead using monitor run method methods need synchronization
BaseDataFileFactory unused methods removed syncSideLog pageToDirty getTempDirectory addition suggest following cleanups remove unused imports remove unnecessary return statement make synchronization object freezeSemaphore final remove unused instance variable backupPath remove unused local variable exception instantiation multipleJBMSWarning replace new Boolean
log database credentials db password expire advised change password using procedure However warning message say need log credentials db change password may lead user modify password current database instead credentials database thinking everything well ij CONNECTION1 gt connect jdbc otherdb WARNING 01J15 password expire 0 day Please use procedure change password ij CONNECTION2 gt CALL 0 rows ij CONNECTION2 gt connect jdbc otherdb ERROR 08004 Connection authentication failure occurred Reason Invalid authentication Even though succeeds password updated credentials db
error message XCY05 rather complex Invalid change property set NATIVE authentication property changed NATIVE NATIVE value accepted property set NATIVE unless credentials database owner stored database using procedure favor simplifying error message possible especially raising specific message error condition DBO added user clear information applies setting database property message trying describe three problem scenarios Turning NATIVE authentication forbidden b Specifying invalid value set database property c Missing credentials DBO
Background Sun jvms bundle Crimson XML parser Xerces IBM jvms bundle Xerces XML parser Crimson J2SE Sun JVMs bundle Xerces instead Crimson according 10 JAXP know anything JVMs use XML parsing Issue basic level support XML datatype uses Apache Xerces 2 parser parser name thus anyone wishing use XML must include Xerces classpath basic XML functionality used available Crimson Xerces parsers Thus nice could improve support parsers perhaps others dynamically thereby allowing XML work regardless whether JVM Sun IBM something else assuming JVM later example useful could perhaps choose parser based JVM use database property Making change would allow people use XML within environments choosing instead forcing download specific parser otherwise Someone using Sun JVM could use XML without download Xerces someone using IBM JVM could use XML without download Crimson someone using Sun JVM could desired download Xerces use parser Sun JVM etc Basically increasing flexibility XML thus making valuable users yet looked detail best make improvement think worth filing future development
SQL roles add parser support SQL roles add upgrade support roles introduce new system catalog SYSROLES database hard upgraded catalog needs added SQL roles Implement authorization stack SQL session context hold current LanguageConnectionContext keeps user authorization identifier SQL session lcc shared context also nested connections opened stored procedures far roles current role stored lcc also However SQL requires authorization identifers pushed authorization stack calling stored procedure cf SQL 2003 vol 2 section GR 5h allows caller keep current role call even changed stored procedure issue implement current role name part cell authorization stack authorization stack implemented part SQL session context patch also implement pushing current unqualified schema name part SQL session context cf GR 5a
contains unused local variable looking removing saw statements method could reordered reduce object creation improve readability
constructor LOBStreamControl EmbedConnection byte always makes buffer size equal LOB size effectively creating extra fully materialized copy LOB memory think assumption LOB already materialized small one LOBs smaller 32 KB fit single page typically materialized read store However sometimes materialize LOBs lot bigger 32 KB example triggers access LOBs may materialize regardless size see comment DMLWriteResultSet constructor details large LOBs sounds unreasonable allocate buffer size LOB suggest change constructor never allocates buffer larger 32KB would mean behaviour preserved LOBs fetched directly store LOBs fit single page cause temporary files created whereas prevent large LOBs accessed triggers duplicated memory overflowing temporary files
Right want connect lowercase authorization id need connect jdbc db dbo use creating NATIVE credentials user call dbo attach patch causes NATIVE procedures normalize USERNAME arguments using key preserves following feature current implementation 1 one set NATIVE credentials stored given authorization id Note differs behavior authentication schemes authentication schemes let store set credentials every permutation authorization id seems like big security hole authentication schemes addition patch following behavior 2 connect username string use calling seems like right casing behavior write tests check
subset tests DatabaseMetaDataTest run part upgrade tests sensitive changes database made tests instance adding tables foreign keys make test fail due extra rows system tables Usually could solved using db wrapper sort upgrade tests database booted several times different versions data needs preserved boots
result spec change introduced longer possible directly set value NATIVE setting happens DBO stores credentials remove confusing references NATIVE error messages
product jars carry version stamps property files stored directory would good test jar carry version stamp useful verifying tests right revision level tor product tested
Currently invalidation statements accessing table issued dropping old statistics writing new ones guarantee compilations see new statistics currently drop statistics index add new ones first drop old ones invalidation work done reduce chances queries compiled without statistics
Currently istat logs affected table twice dropping disposable statistics entries log index affected information useful user wants understand happened orphaned entry system entry dropped computed primary key
replication tests invoke directly order spawn processes run host main test process instead started helper method tests use helper method would make easier example want pass specific flags created test run Note replication tests also code starting processes remote host via ssh local processes started helper method replication tests run part spawned processes run locally
Support use clause CREATE TRIGGER statements clause described SQL standard 2003 chapter lt trigger definition gt lt triggered action gt traces code suggests work done earlier anyone knows something please add comment issue
open DRDAConnThread NetBeans see 49 warnings harmless like static fields accessed via instance suggestions using StringBuilder instead StringBuffer using instead loops Others indicate real problems like use compare SQL states writeSQLDIAGGRP clean warnings easier notice new warnings potential problems
Many methods DDMReader DDMWriter used anymore methods could removed
client classes implement implement interface leaf classes instead base classes unwrap generic signature could base classes long compatible Java example statement class hierarchy implement unwrap Statement40 PreparedStatement40 CallableStatement40 compile client source level move unwrap method Statement class eliminate duplication
Code coverage logical statements improved invoking existing statement tests could done decorator makes use pooled connections
Java 5 introduced new static factory methods called valueOf Number used preference constructors unless fresh instance required valueOf methods allowed cache reuse objects possibly reducing cost memory footprint example int uses cache values default cache size tuned JVM flags server client code compiled Java 5 libraries use valueOf methods get benefits Note also Java 5 numbers uses methods implicitly many cases remove calls constructor compiler automatically insert calls us
interface subset JDBC still JDBC implementation classes extend implementation classes Instead JDBC implementation classes extend common base class reason structure compile targets used optional JDBC classes could depend example class javadoc comment EmbedResultSet169 says ResultSet implementation JSR169 Adds functionality abstract parent class could compiled JSR169 parent class could concrete class environment like JDBC specific classes possible ie easily downloadable jar files class required compiled optional target Since code longer optional comment suggests use base class directly instead would allow us simplify class tree
Change network server code use spaces instead tabs mixed tabs spaces confusing irritating time consuming developers especially network code client spaces server mostly tabs options svn merge svn diff merges reasonable even change tabs 4 spaces files script something like yet tried file files echo file mv file sed lt gt file rm objections change anyone pending DRDA changes would like get make change
Since functions added overlap numeric scaler functions defined section JDBC would benfiical expand table indicate function used JDBC escaped scaler well Plus adding code find call etc add comment later show JDBC escape functions would add
reflection service code creating factory classes class generated SQL queries code disabled due memory concerns remove code reduce code complexity engine jar footprint someone wants enable code later always revive svn history
code added classes generated query compiler example three static fields contain statistics used check plan stale getter setter methods three fields fields accessor methods take 468 bytes every generated class see factor code single shared copy BaseActivation Advantages would less complicated generation less memory occupied generated classes statement cache smaller disk footprint stored prepared statements
waiting Java module system aka project Jigsaw decided define subsets Java SE Platform Specification cf JEP 161 quote JEP broadly feature intended enable migration applications currently built top Java Connected Device Configuration CDC appropriate Profiles Java SE Platform part effort converge CDC Java SE would good make run limited profiles current proposal places JDBC Compact Profile 2 cf link libraries used JNDI Profile 3 larger would good could run smallest posible platform Profile 2 probably involve changes make gracefully limit functionality libraries missing
looking test coverage report noticed methods SQLBoolean class tested falseTruthValue trueTruthValue greaterOrEquals greaterThan lessOrEquals lessThan isNot readExternal hashCode falseTruthValue trueTruthValue never called anywhere code could removed isNot also callers However implement boolean operator part SQL standard might make sense file JIRA add syntax grammar rather removing methods
result set nodes predicate lists compiler lays byte code fields hold qualifiers also code reinitialize values fields every execution even qualifiers See method actually check whether qualifiers skips code generation none changed skips code generation qualifiers example see decompiled generated class natural join attached class contains three Qualifier fields private Qualifier e1 private Qualifier e3 private Qualifier e4 one e4 ever set value Still reinit method called every execution code fields protected void reinit throws StandardException e1 e3 e4
Open JDK 8 include maintenance rev JDBC public discussion JDBC take place want build support JDBC public spec appears time unclear release carry support
constructors many result set classes take GeneratedMethod parameters create row templates ExecRow certain size column types column initialized SQL null value alternative compiler could produce ExecRow instance put savedObjects field GenericPreparedStatement constructors could take parameter points object savedObjects result sets currently invoke generated method produce fresh template could instead clone saved object Advantages suggested approach would Reduce size code generator reduce total code complexity Reduce amount generated code makes easier tools profilers static code analyzers IDEs map executable code source code Reduce actual number generated methods makes less likely queries need use reflection invoke remaining generated methods switchover DirectCall ReflectCall number generated methods exceeds 10
new syntax support Parameters ij toursdb would like following ij gt prepare foo select cities offset rows fetch first 10 rows results following syntax error ERROR 42X01 Syntax error Encountered line 1 column 29 Parameterized important performance prepared security SQL strings created fly
vararg routines added see would like add new vararg system procedure registering unregistering optional packages tools starters would tools checked codeline attached various JIRAs tools DBMDWrapper tool creates functions table functions DatabaseMetaData methods write complicated queries join filter JDBC metadata ForeignTableVTI tool creates views foreign databases foreign data without indirecting csv files also may possible use approach expose log data file reading tools attached new system procedure would look like create procedure toolName varchar 32672 boolean register optionalArgs varchar 32672 language java parameter style modifies sql data external name willFigureOutWhereToPutThis arguments would meanings toolName name specific tool register True means register tool false means unregister tool optionalArgs tool could variable set additional configuration parameters default DBO could run procedure DBO could grant execute permission users known tool names optional parameters would documented Reference Manual section thinking put optional tools might want document optional tools Tools Guide although see arguments documenting tools Admin Guide would appreciate people thoughts proposal Thanks
would useful tool dumping data corrupted database could start custom tool debug tool get experience consider promoting possibly undocumented optional tool ship product think tool following behavior 1 tool subvert security corrupted database corrupted database would need present DBO credentials order use tool Naturally encryption key would presented order decode encrypted database 2 tool stop reading table hits corrupt record Instead tool soldier collect list warnings bad records tool would useful situations part heap table corrupt following heap conglomerates intact SYSSCHEMAS ii SYSTABLES iii SYSCONGLOMERATES iv SYSCOLUMNS v property conglomerate tool would useful situations data dumped even delete log files order recovery
investigating found code could make changes
subclasses public however never used outside package live package access sufficient methods Reducing visibility classes methods silences many warnings IDE NetBeans Typically warnings public methods parameters types Note classes implement Formatable requires classes public public constructors still reduce visibility abstract classes hierarchy well specialized constructors take arguments since used serialization logic
RegisteredFormatIds StoredFormatIds contain identifiers classes implement Formatable interfaces used instances classes Many classes referenced however implement Formatable references could removed seen many classes package none implement Formatable may
new JDBC versions colums added DatabaseMetaData Tests check expectedColumns ignore extra columns prevent failures compatibility testing check occurs assertColumnNames assertColumnTypes
seen indications severe monitor contention SinglePool current lock manager multiple threads access database concurrently thread wants lock object needs obtain monitor SinglePool LockSet global synchronization points leads poor scalability investigate allow concurrency lock manager either extend SinglePool implement new manager
Right trace logic optimizer produce stream diagnostics would good able plug alternative trace logic optimizer would make following possible 1 Plug trace logic produces formats easier study analyzed mechanically xml formatted output 2 Plug trace logic used unit testing verify optimizer picked right plan time might make easier migrate tests tests
Many methods client need handling UnsupportedEncodingException typically call String methods take name encoding argument methods overloads take Charset instead String describe encoding methods throw UnsupportedEncodingException encoding known supported Charset instance use methods take Charset simplify exception handling
ConcurrentXactFactory extends XactFactory replaces XactFactory Hashtable ConcurrentHashMap better scalability ConcurrentHashMap available platforms supported trunk could make XactFactory use ConcurrentHashMap remove ConcurrentXactFactory
two ClassFactory implementations ReflectClassesJava2 Java lower including Java5ClassFactory Java 5 higher base level trunk Java 6 sufficient one ClassFactory
client driver embedded driver factories produce SQLExceptions correct need factories produce JDBC exceptions base level JDBC
StandardException many factory methods creating exceptions warnings example newException methods 0 8 message arguments single method taking vararg argument could replace nine methods
ERROR Subquery allowed return single column PROBLEM using hibernate JPA queries created JPA engine per JPA spec tables PK subqueries created two columns select clause see select Assignment query Without support use JPA Hibernate select distinct Activity Activity inner join ActivitySchedule inner join ActivityScheduleStatus inner join ActivityScheduleStatusType ActivityTypeHierarchy exists select Assignment lt gt lt gt Route ERROR 91 93 91 93 Subquery allowed return single column
Right 2 optimizer implementations one ever loaded implementation disabled following comment use level1 optimizer small configurations codeline 2 implementations entirely chance get picked may running different modules depending jdk resolve Siuling Dan cloudtarget Since deprecated support small CDC configuration think need resolution Siuling Dan Collapsing two optimizers together slightly reduce static footprint
found many methods generate messages could collapsed single method using varargs Right many exist multiple variants typically zero three four message arguments Examples Constructors SqlException SqlWarning
Add method printing xml idea get quick snapshot plan shape without overhead PlanExporter runtimestatistics method could used tests verify plan shapes
would nice able override optimizer choice specify complete query plan using compact summary syntax output XMLOptTrace Given optimizer handles statement would require binding query plan query block level Two obvious candidates feature 1 Extend use comments query 2 Add extra clause query blocks clause would clearly marked extension 1 might look like add new fullQueryPlan property select tablename c 8211 fullQueryPlan union select tablename c 8211 fullQueryPlan 2 might look like add new using join order clause select tablename c using join order union select tablename c using join order comparison approaches 1 Portability query text used different RDBMSes Parsing happens outside grammer 2 Parsing happens parser portable slightly prefer approach 1 pursue approach would like see move parsing parser interested opinions address feature Thanks
FileUtil class uses reflection call following methods setWritable boolean boolean setReadable boolean boolean setExecutable boolean boolean Reflection used methods introduced Java 6 code run older platforms Java 6 lowest supported platform call methods directly
Many methods Predicate class callers methods removed
ERROR nospc internal error caught handled returned user likely bug would useful occurs page dump printed Care taken error returned user internal variety
code SortBufferScan makes NetBeans issue warning return null Incompatible types boolean functional interface lt identifier expected gt expected
opening connection network url jdbc netagent catchs PrivilegedActionException report checked exception Changing lines try new OpenSocketAction server port catch e throw new DisconnectException Error opening socket server server port port message returns check exception information try new OpenSocketAction server port catch e throw new DisconnectException Error opening socket server server port port message currently reports messages like Caused Error opening socket server localhost port 1527 message null fix reports Error opening socket server localhost port 1527 message Connection refused connect
default grows without bounds property set true Setting true helps hands production environment ensure restarts might contain important information lost hand set true grows without bounds problematic long running system really needed ability rolling file support maximum file size maximum number files specified ability configure location log file ie also two methods redirecting error stream standard implementation supports rolling however facility part core system works embedded network server models
suggest implement SQL statement create fill table query without write columns definition CREATE TABLE SELECT SELECT
tried running SELECT MAX indexed column big 8 GB table took 12 minutes 12 minutes expected bit investigation found full index scan performed rows referenced rightmost node actually deleted Possible improvements 1 Implement backwards scan also suggested comments BTreeMaxScan 2 Go parent node next leaf node left side continue valid max value found traversing allowed would ok go latches kept nodes tree course would negative impact concurrency 3 traversal leaf level possible using throw exception page latched without waiting therefore possible try search max value fall back approach conflict arises
ij version ij gt connect jdbc memory db ij gt create type typ external name language java 0 rows ij gt create table ttt x int check cast null typ null 0 rows ij gt insert ttt values ERROR XJ001 Java exception debug build ij gt insert ttt values ERROR XJ001 Java exception ASSERT FAILED current dependent compilation
functions SYSFUN schema use methods directly use methods SystemProcedures instead Java added methods StrictMath possible make functions use StrictMath drop implementation SystemProcedures LOG10 could use COSH could use SINH could use TANH could use
identified unused code flag always false code handling triggers bulk insert unused inspection corroborated JaCoCo results regression tests disable bulk insert triggers present cf DMLModStatementNode getAllRelevantTriggers gt adjustDeferredFlag true InsertResultSet bulkInsert bulkInsert verifyBulkInsert gt bulk insert disabled deferred mode inserts return false
classes lot package visible fields makes hard reason used issue tracks improvements encapsulation classes
suggest implement null ordering option ORDER clause According SQL standard lt sort specification list gt lt null ordering gt NULLS FIRST NULLS LAST
embedded driver raises SQLException linked whose toString method adds SQLState error message SQLException raised client driver linked add SQLState printStackTrace gives information called embedded exception call getSQLState client exception order see SQLState change toString method work way See also discussion
EmbedSQLException used exception raised error JDBC 3 version embedded driver primary purpose EmbedSQLException class gone JDBC minimum JDBC level exceptions vanilla one specialized subtypes SQLException still links EmbedSQLException order provide extra information message id network server needs encoding exception transport wire think possible network server get information StandardException typically also exception chain embedded raises exception currently typically subclass linked EmbedSQLException linked StandardException could find way eliminate EmbedSQLException exception chain stack traces would easier read structure exception chains would consistent client exceptions
encounters exception method called via reflection actual problem may well hidden end long exception chain example ij gt create table x int 0 rows ij gt call null null null null null 0 ERROR 38000 exception exception thrown evaluating expression thrown evaluating expression ERROR 38000 exception thrown evaluating expression ERROR XJ001 Java exception ERROR XIE05 Data file null last exception provides useful information user case think would good remove InvocationTargetException chain easier spot actual problem
class contains many methods longer use remove methods
Another script based test converted JUnit
Implement communication client server
discussion changing errors handled fails restrict file permissions seemed consensus raise exception user explicitly requested setting try restrict file permissions Currently raises error file systems support access control lists case user explicitly requested restriction file permissions two options suggested 1 Raise exception 2 raise exception possibly print warning Option 1 secure one since forces user make decision handle possible security problem either addressing underlying cause failure permissions successfully restricted disabling file restriction functionality Option 2 backward compatible one since gracefully falls back 7 behaviour restrict file permissions
another attempt improve concurrency identity columns previous attempt tracked new attempt try Mike last suggestion use sequences managed reduce contention core catalogs hopeful approach experiments tracked seeing problems related sequence generators seeing lots lock timeouts general shape approach 1 adding identity column table create sequence generator column sequence generator live SYS schema name table UUID 2 DROP SEQUENCE operate sequences sequences TABLE commands 3 add new system function inspecting current value identity generator without getting lock tableSchemaName tableName 4 create sequence every legacy identity column 5 changes take place change behavior identity columns Comments proposal welcome Thanks
parser translates CASE NULLIF expressions ConditionalNodes represents untyped NULLs differently two cases CASE expression branch untyped NULL translated UntypedNullConstantNode wrapped CastNode casts value CHAR 1 CastNode replaced cast correct type bind phase NULLIF expression turned CASE expression NULL clause parser simply creates UntypedNullConstantNode clause without wrapping CastNode CastNode instead added bind phase slight difference NULLs represented parser two cases means ConditionalNode needs handle two cases differently bind phase would better parser generated NULLs way two cases ConditionalNode need know generated CASE expression NULLIF expression
Since JDK 7 use standard decorator JUnit tests return order test fixtures get run indeterministic undesirable add much coverage product makes tests brittle need
Add support UDTs work UDTs Add dblook support UDTs dblook tool support UDTs USAGE privileges granted
repeatedly insert clob table rollback transaction space reclaimed number allocated pages continues grow add test case ClobReclamationTest reference bug may special case bug thought would file bug general issue
Currently uses interfaces package implement XPath support package part Java SE specification Even though package included internal API major Java runtimes using standard package instead would better would portable less likely break future JVM vendors remove internal API
allows users specify names classes use various pluggable modules cases verifies class implements expected interface creates instance class example SpecificAuthenticactionServiceImpl Class sasClass Class specificAuthenticationScheme sasClass throw specificAuthenticationScheme UserAuthenticator aScheme UserAuthenticator cases creates instance without checking instead fails ClassCastException exception trying use instance incorrect type Examples Java5SystemProcedures JCECipherFactory think would good similar checks cases give clearer error messages explain problem safer limits constructors users force engine invoke
Often researching intermittent regression test errors assertion result set fails error report shows column row first fails meet expectations would good assertion methods could dump actual result set cases information go trying understand cause problem
code contains backup methods specifying backup directory String File parameter String versions currently used File versions removed avoid duplication code etc Examples methods plus corresponding interfaces
getNextRowCore method ValidateCheckConstraintResultSet almost exact copy method overrides superclass code reduce brittleness discovered investigating
Currently space reclamation initiated rows MAIN page delted larger page involved row main page keeps pointer page chain main page rows small thus may take lot rows deleted clean reuse space associated extreme case table int key 1 blob column N bytes 32k page probably stores 1000 rows app simply single row grow 1000 N bytes app user order N big would seem reasonable queue post commit delete includes chained keeping current policy queue work possible reclaim entire page problem would extra cost delete time determine row deleted page chain actual information stored field header particular column currently way check would check every field header every column deleted row store point view every column long page chain 8211 currently know datatypes cause behavior options include 1 table create time ask input language say one possible check never done necessary 2 Maintain bit container header sort indication long row exists may simply reference count Note information easily available insert time 3 maintain bit page indicating long rows exist 4 maintain bit record header long columns exist note existing bit whole record overflowed single column overflowed options would used perform slow check delete time necessary really like option 1 unless change storage interface actually behavior lean toward option 4 sort row format change Given system room saved bit believe use without sort work necessary though believe set hard upgrade may old code expect set Soft upgrades get benefit existing data get benefit ideas
one tasks tracked master JIRA
Got request private conversation user databases provide functionality Seems straightforward add
providing SQL support update identity columns using DEFAULT keyword jira look collecting generated keys flag supplied JDBC call UPDATE sql
happens static initialization block start AutoloadedDriver dead code
result poodle security alert SSLv3 SSLv2Hello protocols future good know protocols enabled server side easier know product may impacted security issue specific protocol achieve server boot time list enabled protocols
database adding support popular JSON data interchange format defined could add VTI would unpack JSON document set rows could also add reverse transformation turns query result JSON document
Currently IDENTITY column reaches maximum value produce error tables used transaction logs event logs often makes sense let table automatically start first identity value max reached would similar CYCLE option Oracle SEQUENCE defined probably used quite often purpose guess perhaps even RDBMSs moment every developer program logic propose introduce CYCLE option idea CYCLE based assumption prior cleanup table rows possible ids used previously case rollover happens duplicate value error occur sense argued CYCLE option trade certain error potential error users would possibly gladly accept bargain words option greatly enhance usability IDENTITY columns current implementation IDENTITY columns SQL grammar subset standard first SQL standards define IDENTITY columns Interestingly standard also defines CYCLE option never implemented Also see scroll T174 words proposal simply implement CYCLE defined
basic support XML consists XML datatype three operators XMLPARSE XMLSERIALIZE XMLEXISTS would like enhance existing functionality help move incrementally toward usable complete solution emphasis incrementally attached issue document describing particular changes looking make high level consist 1 Making easier use XML operators datatype within JDBC ex implicit XML values 2 Adding new operator XMLQUERY allow user retrieve results XPath expression instead determining whether expression evaluates empty sequence XMLEXISTS 3 Making changes existing operators line 2005 specification also take steps toward eventual hope support XQuery opposed XPath anyone time interest enough look document provide feedback great
trying import data another database foreignViews tool system tables got corrupted somehow see Tables contain generated ID columns created GENERATED ALWAYS Importing data allowing generate new IDs generated columns break relationships tables old tables counter gaps due deletes IDs match clean import without breaking DDL information DB version control would like able switch generated types follows ALTER TABLE table1 ALTER COLUMN col1 SET GENERATED DEFAULT ALTER TABLE table1 ALTER COLUMN col1 SET GENERATED ALWAYS
ReuseFactory used help reduce object allocations converting primitive types object types ReuseFactory methods wrappers around standard library methods Callers could easily call corresponding valueOf method directly rely ways use cache ReuseFactory currently ReuseFactory purpose anymore One exception still used provides value avoids allocation cost empty byte array needed ArrayUtil class probably good home propose move remove ReuseFactory class
Add MBean allows users monitor CacheFactory instances discussed
JIRA issue used track miscellaneous work producing release
completely disk bound threads might starved real problem multiple clients repeatedly accessing one small number large tables cases like observed high maximum response times several minutes worst cases simple transactions average response time affected starvation caused synchronized block synchronized pageOffset pageData 0 pageSize many threads want read pages file long queue threads waiting monitor Since Java specification guarantee threads waiting monitors treated fairly threads might wait long time get monitor Usually couple threads get full throughput others wait
must entry SYSSTATISTICS table order cardinality statistics SYSSTATISTICS created create statistics exist way create index created empty table seems drop recreate index table loaded documentation also need updating change made
DRDAConnThread currently creates new SQLException object passed writeSQLCAGRP method Profiling shows creation Exception objects takes lot CPU Throwable constructor call fillInStackTrace expensive unnecessary since exception thrown stack trace never used would sufficient keep static SQLException instance DRDAConnThread could reused time doneData called also suggested following comment code sqlstate 02000 end data RESOLVE Need statics sqlcodes Assigning since patch ready sandbox
handling union subqueries list improved materializing invariant resultsets rather creating many times example create view V1 select j T1 union select j T2 create view V2 select b T3 union select b T4 insert T1 values query like select V1 V2 possible resultset V2 created 5 times assuming V2 choosen inner table costly underlying selects take long time also may perform union many times Enhance materialization logic currently returns FALSE always public boolean performMaterialization JBitSet outerTables throws StandardException RESOLVE say materialization right cost based decision return false Actual materialization appropriate placed parent PRN PRN might join condition apply Materialization occur true
currently serializes accesses data file example implementation follows synchronized FileContainer file object pageOffset fileData RandomAccessFile pageData 0 pageSize experiemented patch introduced several file descriptors RandomAccessFile objects per RAFContainer used reading principle readers busy readPage request create new reader maximum number readers patch throughput improved 50 linux discussion see challenge suggested approach make mechanism limit number open file descpriptors Mike Matrigali suggested use existing CacheManager infrastructure purpose discussion see
See new RowPosition replace fetch methods also new RowPosition calls general calls made scans single RowPosition object across life query general try avoid creating objects per row statement gc overhead operating large number rows high
fields columnGotUpdated copyOfDatabaseRow allocated maintained EmbedResultSet every ResultSet required result set updateable saw 5 improvement execution rate simple VALUES clause fixing
result sets exhausted implicitly closed server way send explicit close message generating unnecessary network traffic DRDA protocol supports description OPNQRY open query qryclsimp parameter controls whether target server implicitly closes query upon end data SQLSTATE 02000 association cursor type
similar change setBinaryStreamInternal handled part
Instead copying entire source tree generate javadoc use Ant nested filesets javadoc target specify source files
select would return error syntax finding month group clause select idissue month creation year creation count distinct idissue group idissue month creation year creation
Improve performance page allocation longer requiring sync allocated pages reason sync currently redo recovery handle case redoing allocate finding space available disk tasks like single user load sync allocation significant performance issue case one 1000 insert per transaction total time aproaches close syncing done whole system instance test loading 150 meg db number tables indexes ghz laptop one ide disk sun windows XP got following types results default system 6 minutes alloc sync 1 minute 43 seconds syncing 1 minute 1 second syncing disabled recovery must enhanced handle possible space condition Recovery already handles space undo handle error stop recovery produce error indicating user must add disk space rerun recovery system brought online actually think JVM happen system still asking space syncing values pages disk OS point reserve space file tables let others grab space project make sure space recovery path tests also make sure redo recovery encountering garbage newly allocated page redo create page tested
ContextManagers used extensively particularly get access ExcutionContexts StatementContexts Optimizing access improve overall performance
described JDBC 4 spec sections 21
described JDBC 4 spec sections methods let app servers listen connection statement closure invalidation events Section JDBC 4 spec explains connection events Connection pool managers implement ConnectionEventListener interface register listen connectionClosed fatal connectionErrorOccurred events App servers use events help manage recycling connections back connection pool Section JDBC 4 spec explains statement events Statement pools implement StatementEventListener register listen statementClosed statementErrorOccurred events helps statement pools manage recycling statements back pool
Removed deprecated jdk16 variable machinery builds javadoc jdk16 variable longer needed compilation deprecated part longer need jdk14 variable building javadoc either
Currently Network Server Network Client use 32K blocksize returning database data QRYDTA blocks came across following statement DRDA spec Volume 1 page 12 Blocking applies QRYDTA reply objects query block QRYDTA DSS maximum query block size value allowed qryblksz parameter increased 32K 10M thus accomodating larger data volumes required modern applications importance larger block sizes depends strong application profile example many applications perform selects influenced block size applications seems like ability use larger block size could quite valuable
Incomplete log record write occurs order partial writes gets recognized complete recovery first sector last sector happens get written Current system recognizes incompletely written log records checking length record stored beginning end Format log records written disk length LOG RECORD length mechanism works fine sectors written sequential manner log record size less 2 sectors believe SCSI types disks order necessarily sequential SCSI disk drives may sometimes reordering sectors optimize performance log record spans multiple disk sectors written SCISI type devices possible first last sector written crash occurs recovery system incorrectly interpret log records completely written replay record could lead recovery errors data corruption problem also occur disk drive write cache battery backup make sure request complete
Currently client userid password set connection url default security mechanism upgraded USRIDPWD clear text userid password seems security hole Current client driver supports encrypted EUSRIDPWD via use DH protocol however current Open Group DRDA specifications imposes small prime base generator values 256 bits prevents JCE apt ibm jce used java cryptography providers thoughts 8211 client make check see jvm running supports encryption necessary EUSRIDPWD supports client upgrade EUSRIDPWD 8211 jvm client running doesnt support encryption requirements EUSRIDPWD security mechanism set USRIDPWD 8211 add support strong userid password another option send encrypted passwords across wire gets added maybe considered one upgrade options EUSRIDPWD
Dan Debrunner posted fix allow relaxed durability changes 1 Need add option maybe property 2 Also discussions list Mike suggested logging system changed somehow record database operated manner database goes corrupt waste effort trying figure wrong Probably need way mark log records log control file write message user error log file
reviewing Network Server Code profiling several areas showed potential providing performance improvement Functions need optimizing prevent unneeded object creation excessive decoding parsePKGNAMCSN buildDB2CursorName DDMWriter DDMReader use System Routines instead writing code functions like copy arrays pad strings
Improve testing network server increasing tests cover 100 classes increase method level coverage current code coverage network server based svn revision 208786 Details code coverage EMMA tool available Wiki Links
query contains GROUP clause parser rewrites abstract syntax tree putting aggregates subselect treating clause clause fabricated outer select subquery allows compiler machinery since clause operates grouped result way clause operates list Unfortunately rewriting creates explosion special cases compiler parsing done rewriting systematically handled later compiler gives rise defects like bug 280 need eliminate special rewriting handle clause straightforward way small bugfix medium sized project
allow creation modification databases without requiring disk access space store database
Nicolas Dufour email thread titled functions list started November 2 2005 requests ability create user defined aggregates functionality used Cloudscape disabled presumably considered However machinery needed feature still code user defined aggregates agree acceptable syntax
Java 6 files created would default permissions operating system context Unix would depend effective umask process started Java VM Java 6 7 methods available allows tightening setWritable making less likely somebody would accidentally run lenient default suggest take advantage let default Java 6 higher limit visibility OS user starts VM Unix would equivalent running umask 0077 secure default good think could flag set true would give old behavior
enhancement extends EXPLAIN functions Users want feedback getting current RuntimeStatistics facility extension based functions classes
Set correct collation type derivation result character string types CHAR VARCHAR XMLSERIALIZE functions per wiki page assign correct collation type results CHAR VARCHAR XMLSERIALIZE functions rule copied wiki page follows 6 CHAR VARCHAR XMLSERIALIZE functions look like defined SQL spec behavior defined similar CAST ie result character string collation current schema character set collation derivation implicit Set correct collation type derivation result user defined functions return character string type per wiki page assign correct collation type results user defined functions rule copied wiki page follows 7 user defined functions return character string type return type collation collation character set schema function defined collation derivation implicit Set correct collation type derivation result character string types CURRENT ISOLATION CURRENT SCHEMA CURRENT SQLID per wiki page assign correct collation type esult character string types CURRENT ISOLATION CURRENT SCHEMA CURRENT SQLID rule copied wiki page follows 9 SQL spec Section Syntax Rule 4 says collation type collation character set case mean collation functions collation derivation implicit 10 CURRENT ISOLATION CURRENT SCHEMA CURRENT SQLID seem specific functions find SQL spec order match behavior functions covered 9 return character string type collation collation character set collation derivation implicit
Adding support truncate table command aid portability
Hi Apache Roller team use database migration scripts update databases Roller releases common template run Velocity create specific scripts several databases support One handicap seeing databases inability rename tables FK Renaming one tables returns error rename table website weblog Error Operation RENAME performed object SQL140718163851800 CONSTRAINT dependent object SQLState X0Y25 ErrorCode 30000 Error Operation RENAME performed object SQL140718163851800 CONSTRAINT dependent object SQLState X0Y25 ErrorCode 99999 Error Operation RENAME performed object SQL140718163851800 CONSTRAINT dependent object SQLState X0Y25 ErrorCode 99999 Error Operation RENAME performed object SQL140718163851800 CONSTRAINT dependent object SQLState X0Y25 ErrorCode 99999 Error Operation RENAME performed object SQL140718163851800 CONSTRAINT dependent object SQLState X0Y25 ErrorCode 99999 Error Operation RENAME performed object SQL140718163851800 CONSTRAINT dependent object SQLState X0Y25 ErrorCode 99999 Error Operation RENAME performed object SQL140718163851800 CONSTRAINT dependent object SQLState X0Y25 ErrorCode 99999 results migration scripts needing messy first dropping constraints recreating one RDBMS requires would great future release could coded support table renames regardless constraints defined Thanks
Running scalability tests client buffer manager shows access Hashtable shared long next major sources contention
Network client Add support scrollable updatable insensitive result sets part effort
Open Web Application Security Project suggestions make harder attacker crack hashed passwords builtin authentication service follow suggestions particular add random salt performs hash operation propose add two new properties makes possible configure builtin use random salt run multiple iterations hash operation length random salt add bytes number times perform hash operation also suggest set defaults random salt multiple iterations used default OWASP page mentions 64 bits salt 8 bytes minimum 1000 iterations consulted security expert thought recommendations sounded OK believed recommended salt length likely revised suggested 16 bytes instead price pay going 8 16 bytes need store 8 bytes extra per user database see reason set default high 16 Setting default 1000 make authentication user somewhat slower point really experiments machine suggest running default hash function 1000 times takes around 1 ms Since authentication happens establishing new connection database would negligible cost think saltLength set 0 iterations set 1 hashing done exact way previous versions properties respected data dictionary version higher users databases still log downgrade
Allow unique constraint keys include one nullable fields Prior change supported unique constraints keys included nullable columns new constraint allow unlimited inserts key one null columns limit insert keys null columns 1 unique value per table change existing newly created unique indexes null columns opposed unique constraints null columns Also change existing newly created constraints keys nullable columns
SQL standard describes two kinds CASE expressions simple case searched case current version supports searched case simple case syntax simple case CASE Expression Expression Expression ELSE ElseExpression END Example VALUES CASE 4 1 one 2 two 3 three ELSE many END
Currently allow ORDER nested set operand following construct select t1 order j offset 1 row union select t2 order j desc offset 2 rows allowed standard far understand cf quote section SQL 2011 lt query expression body gt lt query term gt lt query expression body gt UNION lt query term gt lt query expression body gt EXCEPT lt query term gt lt query term gt lt query primary gt lt query term gt INTERSECT lt query primary gt lt query primary gt lt simple table gt lt left paren gt lt query expression body gt lt right paren gt left paren chooses second alternative production lt query primary gt
XAResource interface provides function setTransactionTimeout currently supported client application uses client driver connect database application crashes outside unit work XA transaction transaction committed rolled back yet locks held transaction released
Extend existing functionality adding Java functions SQL support functions multiple arguments
Consider simple case table tbl 10000 rows primary key index i1 query question select tbl i1 table scan entire table even though list two values comparison field index Briefly looking code seems like insert use list get start stop values scan Thus range values list plays important role Thus query changed select tbl i1 1 index scan would chosen would nice could something clever case clearly index field number values list known Maybe use rowcount estimate list size optimizations consider length list searches table ie use list values index key searches table try convert join Use list values create temporary table join likely optimizer choose table list outer table join thus key searches larger table query plans logged using similar queries Table ascending values 0 9999 i1 primary key index i1 GMT Thread 91 main 93 XID 19941 SESSIONID 0 select scanfixed i1 ResultSet 2 Number opens 1 Rows seen 10000 Rows filtered 9990 restriction true projection false constructor time milliseconds 0 open time milliseconds 0 next time milliseconds 0 close time milliseconds 0 restriction time milliseconds 0 projection time milliseconds 0 optimizer estimated row count optimizer estimated cost Source result set Table Scan ResultSet SCANFIXED read committed isolation level using instantaneous share row locking chosen optimizer Number opens 1 Rows seen 10000 Rows filtered 0 Fetch Size 16 constructor time milliseconds 0 open time milliseconds 0 next time milliseconds 0 close time milliseconds 0 next time 0 scan information Bit set columns Number columns Number pages Number rows Number rows Scan start position null stop position null qualifiers Column 91 0 93 91 0 93 Id 0 Operator lt Ordered nulls false Unknown return value false Negate comparison result false Column 91 0 93 91 1 93 Id 0 Operator lt Ordered nulls false Unknown return value true Negate comparison result true optimizer estimated row count optimizer estimated cost l GMT Thread 91 main 93 XID 19216 SESSIONID 0 select scanfixed i1 ResultSet 3 Number opens 1 Rows seen 10 Rows filtered 0 restriction true projection true constructor time milliseconds 0 open time milliseconds 0 next time milliseconds 0 close time milliseconds 0 restriction time milliseconds 0 projection time milliseconds 0 optimizer estimated row count optimizer estimated cost Source result set Index Row Base Row ResultSet SCANFIXED Number opens 1 Rows seen 10 Columns accessed heap 0 1 2 3 4 5 6 7 8 constructor time milliseconds 0 open time milliseconds 0 next time milliseconds 0 close time milliseconds 0 optimizer estimated row count optimizer estimated cost Index Scan ResultSet SCANFIXED using index SCANFIXEDX read committed isolation level using instantaneous share row locking chosen optimizer Number opens 1 Rows seen 10 Rows filtered 0 Fetch Size 16 constructor time milliseconds 0 open time milliseconds 0 next time milliseconds 0 close time milliseconds 0 next time 0 scan information Bit set columns Number columns Number deleted rows Number pages Number rows Number rows Scan Tree start position gt first 1 column Ordered null semantics following columns stop position gt first 1 column Ordered null semantics following columns qualifiers None optimizer estimated row count optimizer estimated cost
Implement new JDBC 4 metadata API getFunctionParameters FI currently implementing return empty result set least compliant able provide real metadata
described JDBC 4 spec sections adds support new Statement methods added JDBC4 addressed JIRAs isClosed getResultSetHoldability
would good built Language based ordering based locale specific Collator Language based ordering important feature international deployment offers one implementation option according discussion issue National Character Types carry fair amount baggage especially form concerns conversion datetime number types Rick mentioned SQL language collations option language based ordering may options thought worthwhile add issue high level functional concern best choice made implementation without assuming National Character Types solution possible workaround examples see user specifies create database url like following jdbc abcDB ignore collation attribute territory attribute specified current code fixed add test case
statement created prepared local transaction using default holdability settting used global transaction default holdability support held cursors global transactions change would allow statements used global transactions returning ResultSets would allow statements cached application servers JDBC section allow holdability handled implementation specific way global transactions believe change forward compatible ever start supporting held cursors global transactions pretty unlikely since functionality displayed holdable functionality
contains piece code remove old entry Conglomerate directory add new one tempCongloms null new Long conglomId new Long conglomId conglom 1 According code coverage report lines tested possible test covers added regression suite 2 null check looks either unnecessary seems case brief inspection code incomplete since last line throw NullPointerException regardless check tempCongloms null 3 call remove put redundant since remove old mapping implicitly 4 seems object put HashMap always one removed perhaps lines could deleted
Get rid finalizer EmbedResultSet Finalizers make object allocation garbage collection expensive avoided object types frequently allocated EmbedResultSet finalize method frequently allocated many types load following comment posted commenting finalize method EmbedResultSet time run test laptop reduced seconds seconds OpenSolaris Sun Java SE 6 Since finalizer activation think investigate whether ways avoid cost ResultSets need finalizer
discussion think case owners trusting database system ensure system attacked maybe booted standalone server security manager involved install one default security policy Thus allowing use Java security manager manage system privileges requiring everyone become familiar imagine policy would allow access databases standalone mean network server started though main method command line
write test verify metadata correct release trajectories terminate release test examine system tables Note N releases 2 lt sup gt N lt gt N 1 trajectories examine
resolved users update statistics committed using maintaining statistics even improve performance difficulty maintaining statistics regular basis would good way drop statistics information users could revert prior behavior needed
