Currently summing longs accumulate get something like Number accumulate sum 3 problems Loss precision long sum 1881617265586265321L incorrectly return 13 much BigDecimal sum also incorrect Loss performance Summing Double total significantly slower summing Long total Integer total Example complexity minor us agree argument use Number abstraction bring value use case worthless complexity Solution proposal discussed Mario Based argument type sum function compiler selects different sum function implementation similar java overloading mechanism 1 selects different method implementation Support sum Long Long accumulate sum sum BigDecimal BigDecimal accumulate sum also support sum Integer sum BigInteger works well consider functions well different jira issue Special case 1 sum Number default sum Double backwards compatibility Number accumulate sum case 2 sum integers long total user use Long accumulate sum long
Configuration lightweight prevents interoperability migrated heaver DOM Element XML fragments
Using different PackageBuilder per namespace pita
Attaching RuleBase packagebuilder allows shell like environment
current action framework allows action specified action node However actions could added locations well actions nodes etc action framework generalized support kinds actions well
Allow direct property access pattern bound variables Allow usage direct property access pattern bound variables Example rule test auto bindings 1 p Person c Cheese type price p end
xml format support variables parameters using different data types like boolean integer object list etc
need reset memories working memory without cancellation events
Add fault node exception handlers process composite context node core XML IDE
Start nodes automatically triggered rules activated event signalled
Processes could listen external events using event node type external process instances automatically notified using kind event correlation event occurs
discussed boot camp add support rules metadata rule xyz foo bar foo2 bar2 end
discussed boot camp add support expressions enabled rule attribute
added Extends keyword DRL grammar rule extends another pull entire LHS parent current rule execution example rule test rule 1 enabled false c Cheese type stilton new String rule 1 end rule test rule 2 extends test rule 1 enabled false Cheese price lt c new String rule 2 end rule test rule 3 extends test rule 2 Cheese price gt c new String rule 3 end Test
Temporal operators must fixed documented Also add support time units parsing
XML file contains composition resources supported kbases built via configuration always programmatically
Update wizards support debugging new session etc
Allow configuration node types used graphical editor
Add jess style accumulate functionality
instance equal cross products removed
Add support fact expiration change expiration offset take account session clock current time also actual event timestamp
history log log information execution process instances also allow logging node instance information database
Currently exists method getWorkingMemoryEntryPoint String return named entry point API call exposed allow collection entry points gathered Collection lt WorkingMemoryEntryPoint gt getWorkingMemoryEntryPoints would useful many ways allow developers maintain entry points list points use IE gui tests rules allowing selection entry point event enters Otherwise developer forced hold sync information outside code messy prone bugs faults typical way would hold list entry points creation hope code removes entry point without updating list Discussed e tirelli IRC
convinient helper function schedule rule executions similar manner cron utility would useful specific use case long running session periodically write data persistence store db file etc current code follows rule DBpoll duration 30s String Run 30seconds elapsed modify end new String Run method work requires external dummy object trigger dynamically generated rules rules pulled libraries etc current developers control difficult ensure suibtable trigger available Therefore cron like function would solve issue envision EVERY keyword possibly COUNT loop style format rule DBpoll EVERY 30s 100 lt means every 30 seconds 100 iterations EVERY 30s 10m lt every 30 seconds 10 mins 30seconds elapsed end
Add tag facts property change support declare MyFact propertyChangeSupport end
often desirable every execute executed latest KnowledgeBase session needs agent aware always check agent latest kbase
chance get performance improvement replacing uses StringBuffer StringBuilder minimum JVM version StringBuilder efficient StringBuffer current uses code javadocs class designed use replacement StringBuffer places string buffer used single thread generally case
Support StateNode Finite State Machines
dynamic node acts node container nodes cleanly connected modeled separate fragments necessarily linked default nodes incoming connection would triggered dynamic node triggered node wait node instances completed continuing Different strategies could also allow rule code constriants define certain fragments activated user add additional node instances runtime even though modeled part process node wait completed well
New APIs Grid
Add forall Conditional Element
lot hard coding ClassObjectType need refactor make generic work style Templates
knowledge agent uses UrlResource fine http https except network Would nice cache resource use last known good version
Add JMX support enable monitoring existing instances
QueryResult wrap returned list used working memory provide conveinience API working result list
Nice new feature Bill Tarr generate rules JDBC result set simple use
Hello trying determine iterate working memory streams within rule following WorkingMemoryEntryPoint entry entry point stream find finid actual text name entry point written rule xxxx way list readable names entry points session would like list entry points drop application profiles one selected one entry point rules inserted Thanks Chris
User might want use verifier validate rules rules
Using listener approach work combination persistence process instances currently loaded notified Using signal approach automatically reload necessary process instances
Grid implementation lightweight distributed environments Version 2
Create simple framework gather data generate reports session useful debugging purposes
Better reporting components caused verifier message Error Warning Note causes causes example redundancy depends subsumptions create tree causes
Allow multiple named consequences used branch conditional elements
Refactoring VSM APIs new Semantic Environments
Unique path better since contains exact path component later used refactoring highlight peace rule caused problem
RuleBuilder instantiates type resolver add entry dynamic imports current package namaspace
Expose StatefulRuleSession fireAllRules AgendaFilter agendaFilter int fireLimit fireAllRules AgendaFilter agendaFilter int fireLimit exposed StatefulSession class StatefulSession extends WorkingMemory API look function class StatefulKnowledgeSession extends StatefulRuleSession method fireAllRules AgendaFilter agendaFilter int fireLimit would like API added switch rule base knowledge base
Create live querries receive change events instead using iterable set
allow rules like eval true
rewriten integration test testDynamicRuleRemovals yields NullPointerException Testcode trace original Testcase leaps compatible always create public void testDynamicRuleRemovals throws Exception Package pkg ruleBase new pkg Native Method Test code modified public void testDynamicRuleRemovalsUnusedWorkingMemory throws Exception PackageBuilder builder new PackageBuilder new InputStreamReader getClass new InputStreamReader getClass new InputStreamReader getClass new InputStreamReader getClass Package pkg reteooRuleBase null leapsRuleBase null RuleBase ruleBase getRuleBase ruleBase new ruleBase instanceof reteooRuleBase ruleBase else ruleBase instanceof leapsRuleBase ruleBase pkg WorkingMemory workingMemory reteooRuleBase null assertEquals 1 assertEquals 4 likes Stilton assertEquals 3 like cheese assertEquals 2 assertEquals 0 else leapsRuleBase null assertEquals 1 assertEquals 4 likes Stilton assertEquals 3 like cheese assertEquals 2 assertEquals 0
Camel integration pipelines
expires policy handled engine hint expiration offset events causing several mistakes misunderstanding users change expires policy override set definitive expiration offset events Example declare StockTick role event expires 10m end cause StockTick events expired 10m memory even rules use temporal operators sliding windows would retain event time would require event memory amount time
Allow users clear specific agenda groups
Rules placed Xor Group rule existing Xor Group fires cancel activations Xor Group
Improve quality tests add test cases clean tests code
Decouple window definitions pattern matching allowing windows reused among various
comes heading knew would happen one day warned people listen Michael always right long run except predicted graphical web browser would take back 1993 catastrophically wrong Someone issues concurrency 5 concurrent threads heavy load creating newWorkingMemory issues weak hashmap points Single rule base spawned working memories surprising blah blah blah Anyway one possible solution call users want update existing long lived working memory changes pass WM rulebase say refresh rules ie methods like removeRule rule base require working memory passed still keep old WeakHashMap make non default behaviour scale way default behaviour opinion STACK trace follows using Java Linux app uses 5 simultaneous threads moment never share WorkingMemory instances share RuleBase thread dump see shows threads stuck called anyone seen attempted synchronize method entry point newWorkingMemory definitely made problem happen less often solve completely Anyone knows workarounds Thanks Per CW4 runnable 91 0x1a2fe000 0x1a2fefb0 93 Source Source Source CW3 runnable 91 0x1a6fe000 0x1a6fee30 93 Source Source Source CW2 runnable 91 0x1a8e5000 0x1a8e5eb0 93 Source Source Source CW1 runnable 91 0x1a966000 0x1a967130 93 Source Source Source CW0 runnable 91 0x1aafe000 0x1aaff1b0 93 Source Source Source
Currently use relational operators String fields MyFact name gt bbb entries results DescrBuildError Evaluator gt support type ValueType String 91 Rule 39 First Rule 39 93 Unable create restriction 91 LiteralRestriction gt bbb 93 field name rule First Rule 91 Rule 39 First Rule 39 93 According docs Operators relational operatory may used whenever type values ordered desirable allow relational operators String fields String Comparable
main goal feature provide unified mechanism marshall objects used persist status knowledge session Two different strategies used sessionInfo ProcessInstanceInfo marshallers Variable Persistence Strategies
Add StrEvaluator list core evaluators Description found
types created enhanced DRL declare construct must retrievable KnowledgeBase using Declare getDeclare String pkg String name Declare object must provide getters String getPackageName getName Map lt String Object gt getMetaData Rule Declare object must provide Class lt gt getFactClass returning created enhanced Declare object must provide long getInferredExpires returning role event inferred expiration offset none
Refactor default working memory entry points use code
Effective rule dates uses TimeMachine instead TimerService things unified
possible support rulebase configuration via jsr94 registerRuleExecutionSet properties Suggestion new property added support handing rulebase config via jsr94 lt code gt RuleExecutionSet lt gt rulebase config constant public static final String modification method probably catch ClassCastException throw jsr94 config exception RuleExecutionSetImpl support rulebase configuration via jsr94 final ruleBase new new Jsr94FactHandleFactory final ruleBase new new Jsr94FactHandleFactory
two main classloaders based around Composite ClassLoader idea causes complexity unified
users able specify dynamic execution expressions typesafe done attribute typesafe false
RuleTerminalNode QueryTerminalNode currently hard coded please allow pluggable factory end developers easily experiment different activation handlers
Java classes defined DRL using declare keyword would good able define Java enums using declare could strip proprietary Guvnor style enums Guvnor UI front DRL supported enums Guvnor currently also supports enums list values one enum dependent upon value another enum enum FUEL values Petrol Diesel enum values Unleaded Super unleaded City disel selected values Unleaded Super unleaded chosen functionality would still need provided Guvnor used restrictions runtime
typesafe workign well decided simplify things apply pattern matches object type type declaration Also need refactor things MVELClassReader take imports things like enums Map keys without fall back Predicate
LeftTuples fields sink actually needs uses memory large volume systems memory save better answer sink specify LeftTuple needs
declaring beans using declare feature metadata attached class field corresponds actual Annotation Annotation present generated class
Migrate GEF rete viewer branch
made small modification WorkingMemory AbstractWorkingMemory allows pause restart rule firing change consists adding boolean isPaused flag plus gettter setter methods inspected loop fireAllRules method follows public synchronized void fireAllRules final AgendaFilter agendaFilter throws FactException try true amp amp agendaFilter finally false good lets stop rule firing within rule want execute external call rule sets call calls setPaused true WorkingMemory fireAllRules exits external process executes call possibly asserting facts WorkingMemory calls setPaused false calls fireAllRules execute call directly rule application execution might take long time want option move WorkingMemory RAM possibly moving another app server continue firing externall call processing completed
like able rule serviceConflict leftProcessAssignment MrProcessAssignment service service machine machine leftId id rightProcessAssignment MrProcessAssignment service service machine machine id gt leftId 1 insertLogical accumulate ConstraintOccurence needed 1 end complex example weight static 1 rule serviceLocationSpread service MrService locationSpread locationSpread spreadCount Number intValue lt locationSpread accumulate location MrLocation exists MrProcessAssignment service service location location count location locationSpread locationSpread spreadCount still used end
able use rules declaratively control conflict resolution
link VerifierComponent descriptions provides simple access information descriptions component associated VerifierMessageBase tested adding VerifierComponent constructor BaseDescr public abstract class VerifierComponent implements Comparable lt VerifierComponent gt Cause private BaseDescr descr public VerifierComponent BaseDescr descr descr integrate Visitors seems work think add test cases provide patch git pull request
Generate invoker classes ASM
trait partially implemented interface attached removed instance runtime
would good possibility add optional name description Resource attribute exposed attributes going exposed yet going implemented Even attributes effect Resource behavior functionality server documentation
JDT compilers work best throw whole lot source dribble though refactor PackageBuilder build set classes compile pass JCI last minute trick map errors back whence came yields 4X speed many cases
RuleBuilder repeatedly hits class type resolver lookup classes even though large ruleset typically looks classes keep cache PackageBuilder level inject RuleBuilder instances needed
method determines events passed parameter occurred public boolean hasAnyEventOccurred String events String events hasEventOccurred return true return false However rules call like hasAnyEventOccurred event1 event2 event3 workaround hasAnyEventOccurred new String event1 event2 event3
MARK Edson want change keyword quite yet sure drastic changes want make syntax think evolve accumulate 1 make first optionall 91 93 documented new separate 2 functions still separated 3 allow optional second boolean expression eval without eval wrapper done separate eval accumulate think good encapsulate intent guard within accumulate also another opportunity remove eval keyword common use case rewrite accumulate place eval CE acc small win think make DRL look nicer especially CEP use cases EDSON Mark 1 2 ok Regarding 3 embed expression accumulate node need separate node use separator need eval keyword
possible use expressions bound variables particular timer attribute rule Parametric timer timer expr x Bean x delay period end
Two distinct sets rules might share need common declared type usually internal utility fact building process however forbids multiple declarations fact different DRLs quickest solution removing declaration one two might feasible two files deployed independently well together Externalizing declarations third file might always feasible especially full control DRLs generated automatically acquired external sources builder recognize equivalent declarations existing one simply ignore
Implement backward compatible binary serialization framework KnowledgeSessions using Google Protobuf framework
allow create rule chaining graphs better detect circular issues necessary add meta data Rule class describing class facts consequence inserts modifies retracts insertions modifications also requested determine fields involved whether populated literals variables
provide command advance time functionality required least highly useful used CEP sessions
Trait Core field mapping requires fields name compatible types Whenever names due interface naming requirements could desirable define custom mapping declare trait X tfield String Alias cField end declare cField String end tField mapped onto hard field cField even names different
seems lots people forgetting add dependencies catch thrown exceptions use refection probe see necessary classes different required jars present give back meaningful message
moment BetaNodes equals constraint Person age age indexed requested create similar indexes also comparison constraints Person age gt age
Implement inline cast described
constraint invokes constructor primitive type argument passing corresponding class type following example class Person public Integer getAgeAsInteger return age rule R1 Person new Integer ageAsInteger lt 40 end constraint jitted following Exception thrown Exception jitting new Integer ageAsInteger lt 40 Native Method Native Method Caused class ConditionEvaluatord12c0fbaca644b0eaff422a71b8812cc method evaluate signature Z Expecting find integer stack
Provide dereferencing operator working described post
Add mechanism creating Kjar jar containing information necessary create already configured kbases ksessions refers using unique name programmatically maven plugin
Externalizable always calls default constructor make sure impl nothing default constructor need refactor code also stop using convenience methods
Need BigDecimal support evaluators Foo bigDecField gt 2 literal converted BigDec etc also BigInteger hard
JIRA explains improvements DRL parser could useful IDE Currently eclipse IDE uses rule parser create outline view based PackageDescr returned parsing DRL file retrieve imports functions queries templates package DRL file used later example performing determine location cursor requesting part rule cursor parsed based unsually partically incomplete PackageDescr returned parser try determine kind location cursor situation beginning column constraint inside eval statement retrieve parameters defined rule possibly certain location requested retrieve errors warnings signal certain syntax errors DRL file places results DRL parser could used determine element selected based character selection range provide syntax checking determine changed DRL changed refactoring automatic error solving Although info returned parser useful think kind reaching boundary info currently returned try describe possible enhancements could allow us advanced IDE features well Use character number addition line number column Eclipse uses character numbers instead line column numbers almost situations character number describes location certain character occurs since beginning file like column since beginning line Although could try create mapping character number line column number resulted annoying errors related newline character different different platforms Using character numbers would eliminate problem elements PackageDescr start location Currently PatternDescr getLine getColumn elements PackageDescr returned parser still FunctionDescr line column imports strings package location able use information advanced features would necessary elements contain start location IDE usually additional parsing determine location elements elements also end location Although PatternDescr getEndLine getEndColumn currently end location ColumnDescr stored thx mic adding already since necessary code completion able use information advanced features would necessary elements contain end location IDE usually additional parsing determine end location elements nested elements much possible Like RuleDescr contains ColumnDescr contains FieldConstraintDescrs elements contain start end location start end course located inside start end location parent believe already working quite well current implementation start location elements parser return much info possible even rule incomplete important since DrlParser used lot DRL yet completely finished example performing would crucial parser return error encounters error tries parse remainder file well tries return much info possible example trying parse following incomplete rule rule MyRule MyClass parser ideally return RuleDescr name MyRule containing lhs one ColumnDescr name MyClass start location end location since end ColumnDescr reached yet since closing bracket missing used work like release noticed though branch returns null Similarly using eval currently EvalDescr added RuleDescr eval closed result IDE redo lot parsing check situations well parser always returns much info available example adding subdescr started finished IDE would much parsing errors warnings try give exact locations drl Although previous improvements made errors returned parser already useful precise feedback could given exact location errors could returned preferably character start end line numbers used well Currently error mostly indicated start line rule contains error precise error determination necessary precise error visualization automatic error solving etc hope kind explains improvements parser could useful IDE
idea use dynamic proxies support shadow facts changes facts queued shadows refreshed propagation finished
Forward Chaining means facts asserted propgated forward throughout network forward propagation matching takes place results rules fired rules event based fired response changed working memory Backward chaining query based Rules attempt fire first necessary matched facts facts pulled external source
profiling shows much time spent iteration loops look using Single Composite Adapters propagations avoid using ArrayLists instead use custom LinkedList arrays
Rule Engine allow WM querried
Instead cloning FactHandle 91 39 93 arrays expensive creating factorial many objects shoudl instead looked sort linked list need copy information parents
Would nice construct like Person address null age lt 30 would kind short circuit ideally Could done special thing alpha nodes another type join node something else common problem users
Implement alpha node hashing ObjectTypeNodes improve performance
would like able specify default expiration offset events default expiration offset used inferred expiration offset infinite Benefits would Expiration guaranteed either specified offset inferred offset Rule authors required include temporal constraint rules Event classes designed rules yet known current behavior Expires fixed expiration offset could default optional attribute could added enable new behavior Role Expires value 10m fixed expiration offset Expires value 10m fixed fixed expiration offset public class MyEvent New behavior Role Expires value 10m default new feature public class MyEvent goal automatic event management times moment either fixed expiration offset set possible analysing rules determining expiration offset manually every rule must include temporal constraint sometimes tough burden rule author feature related think new behavior would touch code fix implemented
Queries able specify results processed reach terminal node
essentially port codebase new front end class makes semantics invoking clearer Initially output DRL point call parser directly LHS RHS etc
need count number meet various criteria example suppose several hundred Town objects list perhaps hundred Person objects need write rules like Find towns three disabled people incomes 100K town 1000 residents 50 poor children age 8 add teacher every 25 children shaky JBR syntax think would translate something like rule disabled ArrayList size gt 50 collect Person disabled yes income gt 100000 stuff end rule teachers town Town population gt 1000 count Arraylist collect Person disabled yes income gt 100000 count size gt 50 25 end really working towns people makes easily understood examples
Currently exists conditional element implemented sequence 2 nodes suboptimal performance adds complexity network specialized constraints requirement specific RightInputAdapterNode Also currently implementation causes unnecessary work performed instance trace work done terminal node following example package query 2 persons status p Person status status age age exists Person status status age gt age end replace current implementation specialized ExistsNode
Implement support additional predicate syntax making gt mandatory anymore Pattern var1 attr1 var2 attr2
like able write constraint determine field value member collection inverse contains keyword proposed syntax 91 bindingVar 93 lt fieldName gt lt someCollection gt picky keyword possibilities containedBy memberOf single word Use case container class field exposes collection record numbers working memory bunch record objects one container object want write rule fires encounters container records matching criteria Container recordNums records Record number recordNums otherField somevalue doStuff current workaround Record num number gt num problematic predicate may
moving JFDI MVEL actively maintained championed
attributes
need support XML bindings Descr classes starting PackageDescr specifically XMLBeans similar etc idea provide XML support need use XML authoring generating tools also provide native XML format use XSLT RuleML OWL etc 1 1 Descr AST classes mostly
Inline JCI strip uneeded dependencies like collections lang io logger
Make TMS optional default help reduce memory usage lage systems
Inline Objenesis library start using remove requirement noarg constructor fact classes previously ShadowProxies required
Implement programmatic RuleEventListener lifecycle described
Eclipse JDT Janino support static imports still targteting byetcode
pushed popped agneda groups exposed event model
stops active currently evaluating rule reveiving activations
RuleBase returns two sessions StatelessSession StatefulSession
possible add invalid rules package
JSR94 Implementation Tests shifted 3 Please integrate JSR94 3 Look zip already contains everything uncommented Tests running
Move templating MVEL drop
p Person bob users may write rules way help code generation use statements field constraints eval using something like MVEL
Allow expression express salience value dynamically
debug view shows realtime audit log selected working memory logger
builder IDE also look files directory take account
Currently properties assignment system properties method need cascading system auto discovery
need make sure LogicTransformer implementation correct
moment configure work old ReteOO engine classpath get ClassNotFoundException case requested log warning automatically switch phreak
querries allow parameters passed
Move shadow facts core involves creating new classloader hold generated classes longer know PackageStoreData use
ConflictResolution configurable set RuleBaseConfiguration
assert becomes insert modify becomes update asertObject modifyObject becomes insert update
Advanced users able disable shadow facts using properties setting RuleBaseConfiguration
Implement incremental accumulate collect CE
Object asserted ObjectTypeNode matches need auto create ObjectTypeNode remembered ensures future added rules facts propagated
Today used hours develop something think quite useful ability externally coded functions accumulate Basically idea common functions predefined template coded every accumulate every rule rule base Example average idea instead writing something like bellow every rule avg Number accumulate Cheese price price init double total 0 int count 0 action total price count reverse total price count result new Double total count user could simply use predefined function like avg Number accumulate Cheese price price average price wants know much cost give 10 raise employees given department sum Number accumulate Employee dept X salary salary sum salary whatever user wants instead hardcoding functions thought better let pluggable defined simple interface AccumulateFunction anyone willing create external function simply implement interface wires using either PackageBuilderConfiguration API configuration files mark created Example constant prefix average function identifier user use rule file DRL XML etc Also provide common functions like average sum count min max etc box since really easy implement function Example implement average function one needs package implementation accumulator capable calculating average values author etirelli public class AverageAccumulator implements AccumulateFunction protected static class AverageData public int count 0 public double total 0 see createContext public Object createContext return new AverageData see init public void init Object context throws Exception AverageData data AverageData context 0 0 see accumulate public void accumulate Object context Object value AverageData data AverageData context Number value see reverse public void reverse Object context Object value throws Exception AverageData data AverageData context Number value see getResult public Object getResult Object context throws Exception AverageData data AverageData context return new Double 0 0 see supportsReverse public boolean supportsReverse return true
new Rule added adds new ObjectTypeNodes need scan ObjectTypdeNodes see contenst assignablefrom ensures propagate facts List ArrayList One key part make sure remove redundance want propagate fact twice matches List ArrayList
Stateless Sessions currently make useable allow sessions inject globals event support objects
need integration tests Duration make sure work
Consider following scenario declare trait sub int end declare X end declare trait Foo fld end declare Bar Traitable logic true new mode fld X end instance b Bar traited Foo value field fld turn traited Truth maintenance transparent casting required goal write rules Foo fld isA 0
add integration tests
add integration tests agenda groups
added setGlobalResolver getGlobalResolver also needed Also working memory longer handle form chaining check provided default resolver
Rules obeying root node lian eval exists parent chain skips nodes need skip nodes reference chain instead skip iteration
Ruleflow agenda groups unified since Specifying attributes rule result one overwritten Specifically RFGs implemented using AGs RFG name one used case conflict warning generated case potential conflicts
Implement new Datadriven annotation rule annotated behave eagerly rete
incremental update feature allows incrementally update KieBase also KieSession updated rules different globals defined different classes original rules different names set global KieSession explicitly checks whether global defined KieBase throw error However incrementally update KieBase global removed rulebase global removed MapGlobalResolver map potentially causing issues memory leaks session incrementally updated globals longer defined new removed MapGlobalResolver See reproducer Clone repo run mvn clean test
Prior Java 8 possible disable constraints jitting setting 0 Since Java 8 removed PermGen space longer possible control disable constraints jitting required provide new option named possible configure many interpreted evaluations constraint jitted Special values property 0 gt force immediate synchronous jitting adviced use testing purposes negative number gt disable jitting Default value 20
rule uses java class pattern package import rule R Cheese end TypeDeclaration class created assigned rule package rather natural class package prevents efficient later lookup typeDeclaration using class name key
possible bind reason facts working memory current rule important remember derived facts time constant
got runtime want inspect rules salience etc via API Currently way retrieve kind information via internal API ie would nice could expose rule attributes via public API
Take given Conditional Element turn children Rete network
need AuditFileLogger work stateful stateless sessions event management methods need refactored common interface
current configuration dialects hard coded main PackageBuilderConfiguration need refactor configurations also pluggeable
allow clips style templates Columns
need integration tests retract assert modify also make sure work
RuleBaseConfiguration allow user specify custom handler consequence exceptions
likely oversight However keep stateless nature API another way add methods interface unfortunately
know method name descr move params onto single line use indexof fine start descr compiled code use find offiset map error descr complex error handling needs reworked CompilationProblem objects stuffed inside rule errors seperate rule errors hence multiple line errors
Users want able add amp amp inside column outside column results multiple sub rules However inside column result nesting values inside single alpha node amp amp However using still result alpha node per entry
LHS normal constraints coerce String gt Date via DateFactory Make MVEL actions date literal string rather guff go setup date
Actions ruleflow support MVEL also support dialects like Java
add lock unlock RuleBase setup rulebase listener progated fireAllRules calls
Allow predicates nested inside field constraint
91 Edson said might already issue 39 find looking 93 Something like possible multipleQueensHorizontal Long accumulate q1 Queen id id Queen id gt id count q1
needed testing effective dating
set rule base use assert behavior expecting able use getFactHandle object method retrieve previously asserted fact providing equivalent equals hashCode object argument appears case AbstractWorkingMemory uses identityMap associated IdentityAssertMapComparator getFactHandle lookup instead assertMap EqualityAssertMapComparator causes lookup done system hashCode method overridden version supplied fact class lookup thus fails returns null See attached unit test
add logical assertion tests
always want use Rules constraints also allow dialectable eval type decisions
parser detect assigning LiteralDescr set field called staticFieldValue true
add contains matches constraints Person addresses foo simple extension contains feature collections sytax ideas Person something contains foo Person something lt lt foo Person something lt lt foo prefer natural possible
need async assert means fact asserted immediately returns Internally based queue one one asserts stacked items working memory Need ot make sure users handle async exceptions might also settings 2 phase commit call fireAllRules call every assertion set time period X facts asserted maybe combination Initially probably esiest call fireAllRules assertion Queue recommend thechannel code stuff borrowed take hte classes need refactor
Currently RuleBase directly coupled PackageCompilationData need around dialect framework
Enhanced process definition language
Context introduced new concept easily group nodes certain context Used basis Variable scope Exception handling Swimlanes
Support timers workflow languages
need pluggable scheduler api components code protected underlying implementation also need default JDK ScheduledThreadPoolExecutor well Quartz impl
Remove ShadowProxy impementation except minimal support interface alone leaving user implement need
