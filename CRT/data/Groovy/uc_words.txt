e.g . to do namespaced navigation like ... Node root = ... // some namespaced doc Namespace xsd = new Namespace ( http : //www.w3.org/2001/XMLSchema , xsd ) def a = root & # 91 ; xsd.annotation & # 93 ; def e = root & # 91 ; xsd.annotation & # 93 ; & # 91 ; xsd.documentation & # 93 ; . 
The project coin proposal for binary literals can be found here attached a patch that allows for those literals and some internal changes to allow the compiler create the correct ints for it . 
When we develop AST transformations , it is often difficult to check that a particular transformation performs what is necessary . For example , we would like , in type checking , to verify that after the type checker has performed its work , a particular AST node contains metadata about the inferred type . Checking this currently requires compilation trickery which is not user-friendly . We propose to add an AST transformation which allows embedding tests . For example , we could test the @ Field AST transformation this way : import groovy.transform . * @ ASTTest ( value = { def owner = node.declaringClass assert owner.fields.any { it.name == x } } @ Field int x . 
Similarily to the matches ( ) method on Matcher , a matchesPartially ( ) method should return true if the string matches the Pattern or if more characters could make that string match the Pattern . . 
This snipset of groovy : def options = def deep = deep , fields .split ( , ) options.subMap ( deep ) fails with error : No signature of method : java.util.LinkedHashMap.subMap ( ) is applicable for argument types : ( [ Ljava.lang.String ; ) values : ] Possible solutions : subMap ( java.util.Collection ) , dump ( ) , spread ( ) , sleep ( long ) . 
When retrieving an node from an XML there is no easy way to clone this node for further processing without changing the original XML . Currently I used a workaround : def clonedNode = new XmlParser ( ) .parseText ( XmlUtil.serialize ( xmlNode ) ) It would be a lot easier if the Node object have a copy constructor or clone would be supported . . 
Add an annotation for closure parameters , which allows to document how methods are resolved in the closure . For example : exec { executable = foo args bar , baz } class Project { ExecResult exec ( @ DelegatesTo ( ExecSpec ) Closure closure ) { ... } } . 
process = ls -al .execute ( ) println process.in.text doesn t work as process.in = a BufferedInputStream and we haven t added getText ( ) to InputStream which would be nice . . 
Provide Mock support with pure Groovy means , i.e . ProxyMetaClass and Interceptors . No external mock library needed any longer . Make use of Ranges and Closures for demanding behaviour . Allow strict and loose expectations in terms of sequence dependency between demand specifications and effected method calls . . 
We currently have Observable versions for Map and List but we re missing Set . . 
Compile groovy classes and scripts along with the standard compilation process of IDEA , using the same class-path , output-path , as the modules within which those classes and scripts are defined . . 
The Groovy logging annotations ( ) currently only allow to change the name of the logger instance in the class , but they don t support to change the logging category . The logging category seems to be hardcoded to be the fully qualified name of the annotated class , e.g . foo.bar.MyClass . It would be nice have the possibility to change this category . Example : package foo.bar @ Commons ( category = some.custom.category.MyClass ) class MyClass { } This would allow to specify custom categories which can then be used in the logging configuration to specify the level . Especially in the Grails framework there are special components ( services , controller ) that use a custom logging category by default that prefixes the component , e.g . grails.services.foo.bar.MyClass . Using the Groovy logging annotations breaks with convention and the logging configuration for these components effectively changes . . 
As discussed here It would be nice to have the @ Immutable transform add a copyWith method ( taking a map ) that returns a new instance of the immutable class . @ groovy.transform.Immutable ( addCopyWith= true ) class Person { String first , last } def p = new Person ( tim , yates ) // Returns same instance def q = p.copyWith ( first : tim ) assert q.is ( p ) // Returns new instance def r = p.copyWith ( first : alice ) assert ! r.is ( p ) assert r.first == alice assert r.last == yates . 
Basically , an out-of-the-Groovy-box implementation of this equivalent transform in Griffon : . 
There needs to be some kind of reflection API for traits , so that programs can reason about traits at runtime . For example , one thing I need to know for Spock is whether a method that , according to Java reflection , is declared in class X , is actually declared in that Groovy class , or inherited from a trait . . 
Provide contains as a DGM method for primitive arrays . There is already count ( ... ) , size ( ) and other methods for primitive arrays but no contains . There is an isCase ( ) method but Java programmers are more familiar with contains so we should provide for that approach too . . 
Iterable , List and Object have tail ( ) , drop ( ) and take ( ) but init ( ) , dropRight ( ) and takeRight ( ) are missing . I added them . The patch is here . Method names are from Scala . . 
It would be great to have an alternate form of min ( ) /max ( ) where closure returns a value to be compared , rather than a comparison . I m often trying to choose the most desirable element of a list , and I have some expression that computes the desirability . Right now I have to do : mylist.max { x , y | my_desirability_expression ( x ) & lt ; = & gt ; my_desirability_expression ( y ) } That s wordy because I need to write the desirability expression twice , and I also need to have explicit arguments for the closure . It would be great if there were a maxv where I could write : mylist.maxv { my_desirability_expression ( it ) } maxv for maximum of value . Similarly with minv . This is trivial to implement ; here s what I use ( a global function ) : def minv ( l , Closure f ) { return l.min { x , y | f ( x ) & lt ; = & gt ; f ( y ) } } . 
Can I send a pull request of List.getIndices ( ) to GitHub ? The method name is from Haskell , Scala and Kotlin . They all use indices not indexes . The implementation is this . public static IntRange getIndices ( List self ) { return new IntRange ( false , 0 , self.size ( ) ) ; } Usage : for ( i in .indices ) { } . 
Remove duplicate entries from Collection . . 
& gt ; - analogous to Collections , an empty Map should & gt ; evaluate to false . . 
Please see the attached patchfile.txt for some new suggested features for the GroovyJDK . The provided test cases should demonstrate its features . Please feel free to provide feedback . Hein . 
Transform each captured group into something else : assert 2 4 6 8 == 1 2 3 4 .replaceAll ( p { Digit } ) { it * 2 } With a new Groovy method on String : public static String replaceAll ( String self , String regex , Closure closure ) { Matcher matcher = Pattern.compile ( regex ) .matcher ( self ) ; if ( matcher.find ( ) ) { matcher.reset ( ) ; StringBuffer sb = new StringBuffer ( ) ; while ( matcher.find ( ) ) { String foundText = self.substring ( matcher.start ( 0 ) , matcher.end ( 0 ) ) ; matcher.appendReplacement ( sb , String.valueOf ( closure.call ( foundText ) ) ) ; } matcher.appendTail ( sb ) ; return sb.toString ( ) ; } else { return self ; } } . 
implement isCase ( ) on Closures like public boolean isCase ( Object candidate ) { return InvokerHelper.asBool ( call ( candidate ) ) ; } to let Closures play as switch cases like in SwitchTest void testSwitchWithClosure ( ) { switch ( 0 ) { case { true } : break default : assert false } switch ( 0 ) { case { false } : assert false } switch ( 0 ) { case { it == 0 } : break default : assert false } switch ( 0 ) { case { candidate - & gt ; candidate == 0 } : break default : assert false } } That way , we can switch on logic . . 
using System.identityHashcode ( object1 ) ==System.identityHashcode ( object2 ) is very inconvenient . suggestions : object1.is ( object2 ) object1.isSame ( object2 ) object1.isIdentical ( object2 ) object1.equalsId ( object2 ) . 
Add a @ BaseScript transformation which allows setting the base script class directly from the script ( that is to say without a compilation option ) . Pull request is here : . 
GPath syntax doesn t support xml with namespaces . The XmlParser class creates special names for xml elements with namespaces ( e.g. , { namespace-uri-here } elementName ) . GPath node selection doesn t support this format . As xml namespaces are commonly used all over the xml world , Gpath would benefit using in a transparent way all nodes , whether with binded namespaces or not . . 
resulted in size ( ) being implemented for StringBuffer . size ( ) should also be implemented for StringBuilder on JDK1.5+ platforms . . 
Groovy should support annotations on local variable declarations . It is syntactically legal to annotate a local variable , but the AST produced does not carry that annotation . My use case with the AST builder . Either we d like to annotate a local variable , like this : @ AstSource ( CompilePhase.CONVERSION ) def source = { println compiled on : $ { new Date ( ) } } Or annotate a property within a closure ( which is a DeclarationExpression ) , like this : def result = new AstBuilder ( ) .build { phase = CompilePhase.CONVERSION @ AstSource source = { println compiled on : $ { new Date ( ) } } } A getAnnotations ( ) method should probably be added to DeclarationExpression to support this . . 
find ( groovy.lang.Closure closure ) and findAll ( groovy.lang.Closure closure ) methods are really useful . It would be also good to have List # indexOf ( groovy.lang.Closure closure ) List # indexOf ( int startIndex , groovy.lang.Closure closure ) // startIndex tells from which index to start looking int List # indicesOfAll ( groovy.lang.Closure closure ) // return type may also be a List & lt ; Integer & gt ; or whatever List # lastIndexOf ( groovy.lang.Closure closure ) in the groovy jdk as it is sometimes important to know where the elements fullfilling the given condition are in the list . . 
new File ( MetaClassTest.class ) .withInputStream { input - & gt ; new File ( output.class ) .withOutputStream { out - & gt ; out & lt ; & lt ; input } } . 
Add the ability to customize Groovy truth , ie . the way the boolean coercion is happening , by letting users be able to define an asBoolean ( ) method on their types . That way , when you use if ( myObject ) , myObject will be evaluated to a boolean through this added method . . 
Let s code some more new groovy methods , extending the core JDK classes . Among them : List.grep ( ) File.grep ( ) List.pop ( ) List.reverseEach ( ) Collection.removeIf ( ) Collection.count ( foo ) Collection.toList ( ) File.withInputStream ( ) String.join ( ) . 
When using other scripting languages a command-line script ( defined using option -e ) has no access to the current line number . The attached patch defines a new variable count that holds the line number for the current file to be parsed . The patched file is GroovyMain.java . 
When writing one-liners in other scripting languages it is very helpful sometimes to automatically have access to an array containing the current line split according to a pattern . This patch adds a commandline option -a that implements this . It takes on optional parameter , the split pattern . If not used , the split pattern is ( a single space ) . The patched file is GroovyMain.java . 
Regroup elements according to a closure criteria inside a map index by the value of the criteria . def expected = def list = & # 91 ; 1 , & quot ; a & quot ; , 2 , & quot ; b & quot ; , 3.5 , 4.6 & # 93 ; def result = list.groupBy { it.class } assert & # 91 ; 1 , 2 & # 93 ; == result & # 91 ; Integer & # 93 ; assert & # 91 ; & quot ; a & quot ; , & quot ; b & quot ; & # 93 ; == result & # 91 ; String & # 93 ; assert & # 91 ; 3.5 , 4.6 & # 93 ; == result & # 91 ; BigDecimal & # 93 ; assert 3 == result.size ( ) . 
When executing a command-line script e.g. , via -pe it would sometimes be very useful to define a method BEGIN and a method END which are executed exactly once , BEGIN before the loop starts , and END after the loop has ended for all files to be processed . An example : groovy -a -ne def BEGIN ( ) { c=0 } ; def END ( ) { println c } ; c += split & # 91 ; 0 & # 93 ; .toInteger ( ) +split & # 91 ; -2 & # 93 ; .toInteger ( ) test.txt results in : 39 for the following test.txt : 1 2 3 4 1 2 3 4 5 1 2 3 4 5 6 1 2 3 4 5 6 7 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 9 The patch provides this functionality and additionally that of and . If a singular patch is necessary , I ll be happy to provide it . . 
Part of the attraction of languages such as Groovy , JRuby is flexible method dispatching ( which is part of metaprogramming ) . How about Self or JavaScript style prototype based OOP with Groovy ? With the addition of a class like ProtoObject class ( attached ProtoObject.java ) , it is possible to do prototype based OOP with Groovy . With ProtoObject , it is possible to write Groovy scripts like the one below : // create a prototype object def p = new ProtoObject ( ) ; // add method to it . p.func = { self - & gt ; println ( hello from + self ) } // create another object def d = new ProtoObject ( ) ; d.greet = { println hello world } // set prototype to be p d._ proto _ = p // prints hello world d.greet ( ) ; // calls p.func ( because of _ proto _ ) d.func ( ) The ProtoObject class is similar to Groovy s Expando . But , Expando sets current ( this ) object as delegate to the Closure & # 8211 ; and therefore will not work property with multithreading . In the ProtoObject class , I m passing this as first argument to Closure . Besides , while a closure s delegate is used for method search within closure code , property access is not direct ( user has to write delegate.property anyway ) - so having explicit self as first argument is probably okay . . 
Deleting a directory including all subdirectories is a very tedious task . A method in File like deleteRecursively ( ) would really help . I am currently using already qutie nice code like this : def dataDir = new File ( ... path ... ) def dirs = dataDir.eachFileRecurse { if ( ! it.isDirectory ( ) ) log.info ( Deleting $ { it.name } : $ { it.delete ( ) } ) else dirs & lt ; & lt ; it } dirs.reverse ( ) .each { log.info ( Deleting directory : $ { it.name } : $ { it.delete ( ) } ) } But why could it not be new File ( ... dir ... ) .deleteDir ( ) or similar ? . 
Provide a way to get the result of the addition of 2 Maps , eg : assert + == In terms of Map semantics , which would take priority for duplicate keys , left or right ? Considering Java s Map.putAll ( ) , which blindly adds all elements in the given map , perhaps the right side , should take precedence , so : assert + == What do others think ? Original email thread : . 
When working with Maps , there are two scenarios : You want a special default value if a key doesn t exist ( ie . not null ) You want to create a new object if a key doesn t exist Proposed syntax : def map = new HashMap ( defaultValue : xxx ) map.put ( x , a ) assert map.x == a assert map.y == xxx map = & # 91 ; : & # 93 ; x = map.get ( y ) { New $ { it } } assert x == New y assert map.size ( ) == 1 assert map.keys ( ) = map = & # 91 ; : & # 93 ; { New $ { it } } x = map.y assert x == New y assert map.size ( ) == 1 assert map.keys ( ) = Abstract : You can specify a constant value or a closure when creating a map and when getting values from it . If a key doesn t exist , the constant will be returned or the result of running the closure . The missing key is the parameter for the closure . Note : For checking if a key doesn t exist , it s not sufficient to check whether map.get ( ) returns null because Maps can contain null values . Implementation note : I suggest to implement this using a wrapper DefaultValueMap which handles the default case . All methods but get ( ) are simply forwarded to the wrapped Map . get ( ) looks like this : public Object get ( Object key ) { if ( ! containsKey ( key ) ) return defaultValue ; return super.get ( key ) ; } Open questions : What happens when the closure returns null ? Maybe the new key/value pair shouldn t be added in this case . Or do we want to add a new exception for this ? . 
on File the GDK has following methods void eachDir ( closure ) void eachFile ( closure ) void eachFileMatch ( filter , closure ) void eachFileRecurse ( closure ) for coherence it would be good to have : void eachDirMatch ( filter , closure ) void eachDirRecurse ( closure ) See discussion in dev mailing list : . 
synchronize ( expression ) { } . 
It would be good to have : oos & lt ; & lt ; object as a shorthand for : oos.writeObject ( object ) . 
Wii currently have : socket.withStreams { input , output - & gt ; ... } I have a similar suggestion to mirror this for Object variants : socket.withObjectStreams { ois , oos - & gt ; ... } This would make setting up proxy type objects over sockets very streamlined . . 
John Wilson suggested this improved syntax for catching several exceptions at once : This has been suggested for Java I would have thought it s trivial to do in Groovy try { Field field = someClass.getDeclaredField ( someField ) ; someValue = field.getInt ( Barcode.class ) ; } catch ( SecurityException , NoSuchFieldException e ) { // do something else with the exception } . 
def lists = assert lists.combinations ( ) as Set == as Set . 
We need to add support for propertyMissing as well as methodMissing . Example : // for getters Foo.metaClass.propertyMissing = { String name - & gt ; } // for setters Foo.metaClass.propertyMissing = { String name , Object value - & gt ; } . 
I am trying to use XmlSlurper to process and xml with nested elements with text in them . I need to get the text from just one level at a time but the text ( ) method returns all text for all childrend and I can t see anything that would bring back just the local . Here is a sample from the console : groovy & gt ; def model = new XmlSlurper ( ) .parseText ( & lt ; aModel & gt ; & lt ; aParent name= bubba & gt ; text & lt ; aChild & gt ; child text & lt ; /aChild & gt ; & lt ; /aParent & gt ; & lt ; /aModel & gt ; ) groovy & gt ; model.aParent & # 91 ; 0 & # 93 ; .text ( ) groovy & gt ; groovy & gt ; Result : textchild text . 
Groovy should have a transpose method like : Ruby s transpose ( ) method on arrays Python s zip ( ) method expected behaviour : assert .transpose ( ) == assert transpose ( & # 91 ; & # 39 ; a & # 39 ; , & # 39 ; b & # 39 ; & # 93 ; , & # 91 ; 1 , 2 , 3 & # 93 ; ) == assert transpose ( & # 91 ; 1 , 2 , 3 & # 93 ; , & # 91 ; 4 , 5 , 6 & # 93 ; ) == assert transpose ( & # 91 ; 1 , 2 , 3 & # 93 ; , & # 91 ; 4 , 5 & # 93 ; , & # 91 ; 9 & # 93 ; , & # 91 ; 6 , 7 , 8 & # 93 ; ) == assert transpose ( & # 91 ; 1 , 2 , 3 & # 93 ; ) == assert transpose ( ) == . 
ObservableMap will fire PropertyChangeEvents when put ( ) and putAll ( ) are called on it . It will work as a decorator for other Maps but if none is passed as an argument it will wrap a HashMap . Jochen suggested that a closure may optionally be used to discriminate which property may fire and event when its value changes , this is useful for constructing observable Expandos with the following code // will filter out all methods added to the Expando def bean = new Expando ( new ObservableMap ( $ ! ( it instanceof Closure ) } ) ) bean.lang = Java // will not trigger because previous value was null bean.lang = Groovy // will trigger because previousValue ! = newValue bean.callMe = { hello $ { it } } // will not trigger because value is a Closure bean.callMe = { again $ it } // idem , even if value did changed . 
It would be nice to support subscript access on BitSet objects . def bitSet = new BitSet ( ) bitSet = true bitSet = true def value = bitSet def subSet = bitSet . 
Currently we have list * .method ( ) that invokes the method on all items in the list . It would be useful to also support list * * .method ( ) that invokes the method on all items in the list and recursively for any lists within the list . def animalLists= , ] assert animalLists.size ( ) == 2 assert animalLists * .size ( ) == assert animalLists * * .size ( ) == , ] . 
It would be cool if the as keyword could be used to coerce strings to enum values . Since this currently throws an exception , adding this functionality should have no impact on existing code . . 
I recently came across a situation where I wanted to initialize a JCE Certificate directly from a URL . I wanted to do this : def cfUrl = args.toURL ( ) def cf = CertificateFactory.getInstance ( X.509 ) def newRootCert = cfUrl.withInputStream { cf.generateCertificate ( it ) } Putting aside the fact that the with * methods don t return the closure return value ( which I m going to create a separate JIRA for ) , there is not currently a withInputStream method for URL . I could do something like this to work around it , but I d rather do it the Groovier way : def newRootCert = cfUrl.openStream ( ) .withStream { cf.generateCertificate ( it ) } I ve attached a patch to add URL.newInputStream and URL.withInputStream . It doesn t have any tests because I couldn t find any existing tests for URL.withReader ( or File.withInputStream for that matter ) and wasn t sure what the best way to handle it would be . . 
hi , I talked to james and he liked the idea of adding a simple Thread.start ( Closure c ) so that you can easily run things in new threads . example : thread = Thread.start { process = some long running process .execute ( ) ; process.waitFor ( ) ; } .. do something else while this runs . . 
Half-Mocks are mocks for classes with dynamic methods or properties . One example are Grails domain objects where you would use the implemented domain specific methods but want to mock the GORM methods . . 
I ve frequently run across the situation where I want to create a map from two equal sized lists , using one list for the keys and a second list for the values . Maybe I m missing something , but I can t seem to find a compact way to do this that doesn t require a for loop or an intermediate variable . The best I ve come up with is to add this method to Map : Map.metaClass.putEach = { List keylist , List valuelist - & gt ; assert keylist.size == valuelist.size for ( int i=0 ; i & lt ; keylist.size ; i++ ) { delegate.put ( keylist , valuelist ) } delegate } This allows you to just call putEach on any Map passing in two equal sized lists , e.g . : assert & # 91 ; : & # 93 ; .putEach ( & # 91 ; & # 39 ; key1 & # 39 ; , & # 39 ; key2 & # 39 ; , & # 39 ; key3 & # 39 ; & # 93 ; , & # 91 ; & # 39 ; value1 & # 39 ; , & # 39 ; value2 & # 39 ; , & # 39 ; value3 & # 39 ; & # 93 ; ) == & # 91 ; & # 39 ; key1 & # 39 ; : & # 39 ; value1 & # 39 ; , & # 39 ; key2 & # 39 ; : & # 39 ; value2 & # 39 ; , & # 39 ; key3 & # 39 ; : & # 39 ; value3 & # 39 ; & # 93 ; Since this seems generally useful , it might be something worth adding to the base GDK . . 
Many methods in GDK could be type-parameterized to reflect generic collections . For example adding two maps/lists with plus or obtaining elements with getAt . This will not affect runtime semantics of respective methods , but make more powerful static analyzes possible . . 
The new @ Bindable annotation is great . It ( further ) reduces the amount of boilerplate code required in Groovy beans . The next logical step is an @ Identity annotation that can be applied to one or more attributes , telling Groovy that those properties define the identity / business key / whatever-you-want-to-call-it of the bean . The object s equals ( ) , hashCode ( ) and toString ( ) would behave accordingly . May be related to , but I m not sure ( was marked Won t Fix ) . . 
Allow use of a Groovy compiler flag to enable type checking for all classes and methods except for the classes and methods annotated with a @ TypeUnchecked annotation ( or another antonym of @ TypeChecked such as @ NotTypeChecked or @ RuntimeTypeChecked or @ TestInProduction or @ YouNeedExtraUnitTestsForThis ) For large projects with hundreds of classes , where we want type checking on 99 % of the code , it would be too much boilerplate to remember to put @ TypeChecked annotations on every class . It would also require us to refactor methods containing dynamic code into separate non-type-checked classes just to satisfy the @ TypeChecked contract . It would be better to have a compiler flag to reverse the type checking contract so everything is type checked except for the classes and methods that are explicitly marked for allowing dynamic code . Discussed with Guillaume Laforge after his talk about Groovy 2.0 at GR8Conf 2012 in Copenhagen . He agreed it would be a good addition for Groovy 2.1 , and that I should open a Jira ticket . Another audience member had the same request as well . . 
ObservableList provides similar behavior as groovy.util.ObservableMap to List . It will also fire events whenever elements are added , removed , cleared and multi added/removed ( via allAll , removeAll , retainAll ) . . 
GDK convenience methods to wrap SimpleDateFormat such as { { new Date ( ) .format ( yyyy-MM-dd ) } } . These should probably added for Calendar too . Would a complimentary parse method be appropriate ? . 
This jira is to document the fact that an annotation has been written . Further discussion : There is still debate over whether this should move to a contrib area . This issue should be updated if such a change is made . Cheers , Paul . . 
Based on mailing list feedback it seems like split ( ) is worthwhile but partition ( ) can almost as easily be replicated using groupBy so maybe not worth it . The functionality is the same as findAll ( ) but returns both the accepted and rejected elements in two lists . . 
Currently , it s only possible to create instance groovy methods . Such as file = new File ( text.txt ) file.eachLine { line | println it } But we can not currently add static methods , such as ( ) : thread = Thread.start { process = some long running process .execute ( ) ; process.waitFor ( ) ; } . 
current suggestion is to use a @ PackageScope AST macro . 
Groovy provides a very convenient encodeBase64 method in byte . It would be even more convenient if there were also an encodeHex method in byte . See .html # encodeBase64 ( ) ] The Apache Commons Codec project provides an implementation of a hex encoder but it would also be trivial to implement from scratch . This feature would be immensely convenient when working with checksums . 
As explained in the following thread Scals provides a stripMargin ( ) method to its multi-line strings which is very helpful in overall situations . For something fancier not covered by the default behavior the user will have to roll its own impl . Link to Scala api docs . 
I suggest to introduce a new AST transformation @ InheritConstructors which can be placed on a class and the class with this annotation will inherit all the constructors of its super class . For example : class A { A ( ) { } A ( int arg ) { } A ( String arg ) { } } @ InheritConstructors class B extends A { } Then class B will be equal to : class B extends A { B ( ) { super ( ) } B ( int arg ) { super ( arg ) } B ( String arg ) { super ( arg ) } } I think it is useful , especially for defining exceptions . . 
Groovy makes working with regular expressions much easier than Java , but there are still a couple of holes in the 1.6 implementation . I ve attached a patch that adds a couple of simple methods that make regular expressions much easier to use . One of the most common use cases is to search a string for a regular expression pattern . If a match is found , then do something with the matched value . Currently in groovy , the recommended way to do this is to create a matcher and then use indexes to work with any matches that might be found : assert 10292 == ( New York , NY 10292 =~ /\d { 5 } / ) & # 91 ; 0 & # 93 ; If you try to do that on a string that doesn t actually match the regular expression , you ll get an IndexOutOfBoundException . To be safe , you need to check matcher.find ( ) ( not matches as that requires the entire string to match ! ) to see if the string is actually in there : def m = ( New York , NY =~ /\d { 5 } / ) & # 91 ; 0 & # 93 ; def zip if ( m.find ( ) ) { zip = m } It also has inconsistent behavior if the regular expression happens to have capture groups in it . Then it returns an array containing the match and the capture groups , forcing you to index into that array to actually get the match you want : assert c == ( foo car baz =~ / ( . ) ar/ ) & # 91 ; 0 & # 93 ; & # 91 ; 1 & # 93 ; Groovy has already added closure aware replace method to the String class . The patch adds a complimentary find method to string that will return the string matched by the closure without needing to worry about matcher objects and array indexes . You can either call it without a closure to get the full found match back ( even if it has groups in it ) : assert 10292 == New York , NY 10292 .find ( /\d { 5 } / ) It safely returns a null if the match isn t found , which can clean up boilerplate safety checks quite a bit . The user can check for null using groovy truth if they want to : def zip = New York , NY .find ( /\d { 5 } / ) // returns null if ( zip ) { ... } If you want to work with capture groups , or manipulate the value , you can pass a closure to the find method that will be passed the full match as well as any capture groups ( just as the collection based regular expression methods work ) : // no capture groups , only the match is passed to the closure assert bar == foo bar baz .find ( /.ar/ ) { match - & gt ; return match } // one capture group assert b == foo bar baz .find ( / ( . ) ar/ ) { match , firstLetter - & gt ; return firstLetter } // many capture groups , all passed to the closure after the full match assert 2339999 == adsf 233-9999 adsf .find ( / ( \d { 3 } ) ? - ? ( \d { 3 } ) - ( \d { 4 } ) / ) { match , areaCode , exchange , stationNumber - & gt ; assert 233-9999 == match assert null == areaCode assert 233 == exchange assert 9999 == stationNumber return $ exchange $ stationNumber } The patch also includes a number of unit tests to exercise and demonstrate the functionality . I get the most traffic on my blog to a post that I did explaning regular expressions in groovy , and I think that people struggle a bit with the current implementation . I think this patch makes working with regular expressions much easier and more intuitive . . 
Ages ago i wrote a spell checker for groovy , that gives more helpful information in case a MissingMethodExeption or Missing Property Exception is thrown . I recently picked it up and finished the patch . It uses reflection to find missing methods with a low edit distance relative to the requested method . It also use the edit distance as a method to rank the method so that the most probable solution is displayed first . The performance impact is isolated to exception.getMessage for properties and Methods , but not for constructors . I don t know of a case where this should impact a working program but it should be taken into consideration . The unit tests are only partial ( they era complete for the string/array metrics ) but the other coverage is currently weak . Missing method ================================================================ groovy:000 & gt ; Integer.vallueOf ( 10 ) ERROR groovy.lang.MissingMethodException : No signature of method : static java.lang.Integer.vallueOf ( ) is applicable for argument types : ( java.lang.String ) values : & # 91 ; 10 & # 93 ; Possible solutions : valueOf ( java.lang.String ) , valueOf ( java.lang.String , int ) , valueOf ( int ) at groovysh_evaluate.run ( groovysh_evaluate:2 ) groovy:000 & gt ; Missing Constructor ================================================================ new Integer ( new Object ( ) ) ERROR groovy.lang.GroovyRuntimeException : Could not find matching constructor for : java.lang.Integer ( java.lang.Object ) Possible solutions : java.lang.Integer ( int ) , java.lang.Integer ( java.lang.String ) at groovysh_evaluate.run ( groovysh_evaluate:2 ) Missing Constructor ================================================================ new java.awt.Point ( ) .xy ERROR groovy.lang.MissingPropertyException : No such property : xy for class : java.awt.Point Possible solutions : x , y at groovysh_evaluate.run ( groovysh_evaluate:2 ) . 
Some swing models do not follow a naming standard for common operations like get ( int ) , set ( int , element ) , clear ( ) nor they provide an iterator ( ) method ( for those that make sense ) . This is a request to enhance Swing classes and models with additional methods that bridge the gap with useful collection/groovy methods . This is a port of . 
Please add an option for grape to generate ivy dependencies from the command line , just like -ant or -dos options . For example , this command : grape resolve -ivy org.apache.poi poi 3.5-beta6 org.apache.poi poi-ooxml 3.5-beta6 Could generate the following output : & lt ; dependency org= org.apache.poi name= poi revision= 3.5-beta6 / & gt ; & lt ; dependency org= org.apache.poi name= poi-ooxml revision= 3.5-beta6 / & gt ; . 
In File s some convenient methods like File # eachLine ( ) , File # splitEachLine ( ) and others , there is no way to specify the encoding for reading . For example , there is no File # eachLine ( String charSet , Closure c ) method . Of cource , we can write : new InputStreamReader ( new FileInputStream ( new File ( file_to_read.txt ) ) , charSet ) .eachLine { .. } but this is not so groovy . My proposal is , to add encoding ( ) method to java.io.File as a GDK enhancement method , which can be used like : new File ( args ) .encoding ( utf-8 ) .eachLine { println it } As reference , if write it by EMC , the definition of method encoding is like : File.metaClass.encoding = { cs - & gt ; new InputStreamReader ( new FileInputStream ( delegate ) , cs ) } GDK of java.io.InputStreamReader has equivalents each * methods , this is enough . . 
Currently we need to edit the ~/.groovy/grapConfig.xml to make Grape aware of a new Maven2 repository . To address this we can add a new annotation . E.g . : @ GrapeResolver ( name= restlet.org , root= http : //maven.restlet.org ) @ Grab ( group= org.restlet , module= org.restlet , version= 1.1.6 ) 
InputStream , URL and File have a getText method , but they don t have the same for byte . This patch add the method getBytes . ex : content=new File ( README.txt ) .bytes content=new URL ( http : //www.google.fr ) .bytes content=new ByteArrayInputStream ( & # 91 ; 1,2,3,4,5,6,7,8,9,0 & # 93 ; as byte ) .bytes . 
Sometimes in troubleshooting the groovy issues , it is helpful to know if a groovy class was compiled with one groovy version and is being run with an incompatible groovy version . Currently , in the pre-compiled classes , groovy compiler leaves no signs of its version behind . A run-time annotation can be introduced to store the groovy version , which can subsequently be retrieved to know the origin of that groovy class . . 
See : . 
Currently , Groovy equality extends to arrays and lists , but not to sets and maps . Example : assert == // passes assert as Set == as Set // fails This is surprising and ungroovy . It would be nice to have Groovy equality for sets and maps too . The drawback is that it would make set/map equality inconsistent with lookup results ( i.e . two sets are equal but Set.contains ( ) yields different results ) . On the other hand , the same problem already exists for Groovy list equality . For maps , one could avoid the ( lookup ) inconsistency by only using Groovy equality for values . It would be good to have a discussion about this proposal . . 
Sometimes you don t want to curry from the left hand side . You can always fake it by rewriting a reversed method or Closure manually but most functional languages support currying from the right or an arbitrary index . An rcurry method allows examples like this : def divide = { a , b - & gt ; a / b } def halver = divide.rcurry ( 2 ) assert halver ( 8 ) == 4 An ncurry method would allow , as an example , to curry the middle parameter of a three argument method , e.g . : // curry middle param of this utility method : // Collections # binarySearch ( List list , Object key , Comparator c ) def catSearcher = Collections. & amp ; binarySearch.ncurry ( 1 , cat ) def result = catSearcher ( myList , myComparator ) . 
Iterating over date intervals is currently possible using the following code : def start = new GregorianCalendar ( 2010 , Calendar.JANUARY , 1 ) .time def end = new GregorianCalendar ( 2010 , Calendar.DECEMBER , 31 ) .time def current = start while ( current & lt ; = end ) { println current current++ } But following the style in which numbers are iterated , we can have a groovier code : start.upTo ( end ) { println it } end.downTo ( start ) { println it } Proposed implementation : Date.metaClass { upTo & lt ; & lt ; { Date end , Closure c - & gt ; def next = delegate while ( next & lt ; = end ) { c.call ( next ) next++ } } downTo & lt ; & lt ; { Date start , Closure c - & gt ; def next = delegate while ( next & gt ; = start ) { c.call ( next ) next -- } } } . 
Unix has a tr translation command . It would be good for Groovy to support something similar . Translations similar to what tr does can be achieved using regular expressions but the notation required is much more compact and the implementation can be much more efficient . . 
The kind of code you write when setting up and using the JSR-223 engine is often fairly similar . Some syntactic sugar might improve the look of such code in polyglot scenarios . . 
It would be useful to support this : assert hello .capitalize ( ) == Hello . 
When using Groovy as a * nix shell replacement , it would be useful to support the following : assert \t\tabc\tdef\n12345\t67\t .expand ( ) .unexpand ( ) == \t\tabc\tdef\n12345\t67\t assert 1234567\t8\t .expand ( ) == 1234567 8 assert x .unexpand ( ) == x\t assert x \n .unexpand ( ) == x\t \n . 
As a minor but useful convenience for concurrent scenarios , it would be useful for Groovy to have a @ Synchronized annotation similar to that offered by project Lombok : It just makes it easier to follow good practice without having to remember all the rules . . 
With regards to a thread in the groovy user list here : A take ( n ) method would be a really useful addition to the Groovy codebase It is assumed it will work similar to other languages , in that : def a = assert a.take ( 0 ) == assert a.take ( 1 ) == assert a.take ( 4 ) == The method should work for Collection , String , Map and lazily for Iterator , Reader and InputStream . 
Mister Jamie McCrindle suggested we had some new groovy for sockets and server sockets . Socket.withStreams ( Closure ) ServerSocket.accept ( Closure ) Jamie , some more ideas of methods ? . 
It would be useful to support something like F # s compose & gt ; & gt ; operator for Closures , e.g . : def twice = { a - & gt ; a * 2 } def inc = { b - & gt ; b + 1 } def f = inc & gt ; & gt ; twice def g = { x - & gt ; twice ( inc ( x ) ) } // longhand equivalent assert f ( 10 ) == 22 assert g ( 10 ) == 22 def string2char = { it.chars } def p = Integer . & amp ; toHexString & gt ; & gt ; string2char & gt ; & gt ; Character . & amp ; toUpperCase assert p ( 15 ) == F def multiply = { a , b - & gt ; a * b } def identity = { a - & gt ; } def sq = identity & gt ; & gt ; multiply assert ( 1 .. 5 ) .collect { sq ( it ) } == . 
Implement closure memoization , like in GPars . . 
add support for @ WithReadLock and @ WithWriteLock declarative synchronization As per the discussion here : I ll commit this myself , but am looking for feedback . This code : import groovy.transform . * ; public class ResourceProvider { private final Map & lt ; String , String & gt ; data = new HashMap & lt ; String , String & gt ; ( ) ; @ WithReadLock public String getResource ( String key ) throws Exception { return data.get ( key ) ; } @ WithWriteLock public void refresh ( ) throws Exception { //reload the resources into memory } } Becomes this Code : import java.util.concurrent.locks.ReentrantReadWriteLock ; import java.util.concurrent.locks.ReadWriteLock ; public class ResourceProvider { private final ReadWriteLock $ reentrantlock = new ReentrantReadWriteLock ( ) ; private final Map & lt ; String , String & gt ; data = new HashMap & lt ; String , String & gt ; ( ) ; public String getResource ( String key ) throws Exception { $ reentrantlock.readLock ( ) .lock ( ) ; try { return data.get ( key ) ; } finally { $ reentrantlock.readLock ( ) .unlock ( ) ; } } public void refresh ( ) throws Exception { $ reentrantlock.writeLock ( ) .lock ( ) ; try { //reload the resources into memory } finally { $ reentrantlock.writeLock ( ) .unlock ( ) ; } } } You can also specify your own lock , like so : import groovy.transforms . * ; public class ResourceProvider { private final ReadWriteLock myLock = new ReentrantReadWriteLock ( ) ; private final Map & lt ; String , String & gt ; data = new HashMap & lt ; String , String & gt ; ( ) ; @ WithReadLock ( myLock ) public String getResource ( String key ) throws Exception { return data.get ( key ) ; } @ WithWriteLock ( myLock ) public void refresh ( ) throws Exception { //reload the resources into memory } } In which case the code becomes : public class ResourceProvider { private final ReadWriteLock myLock = new ReentrantReadWriteLock ( ) ; private final Map & lt ; String , String & gt ; data = new HashMap & lt ; String , String & gt ; ( ) ; public String getResource ( String key ) throws Exception { myLock.readLock ( ) .lock ( ) ; try { return data.get ( key ) ; } finally { myLock.readLock ( ) .unlock ( ) ; } } public void refresh ( ) throws Exception { myLock.writeLock ( ) .lock ( ) ; try { //reload the resources into memory } finally { myLock.writeLock ( ) .unlock ( ) ; } } } . 
Add trampoline capabilities to closures , to avoid StackOverflowException when using closures with lots of recursive calls . Patch contributed by VÃ¡clav . . 
Following the discussion at , this AST Transformation allows transparent script interruption when the worker thread is interrupted . It adds thread interruption checks on several points of code : closures different types of loops method first statement The attached file is a preliminary implementation which does not propagate to the CompilationUnit yet ( haven t found how to do it properly ) + a simple script which I use for tests . Feel free to review , patch , ... . 
DGM # min ( Map map , Closure closure ) will be a shorthand for map.entrySet ( ) .min ( closure ) . Likewise for max . . 
Write an AST Transformation which allows the user to create custom interrupt conditions , instead of the Thread.currentThread ( ) .isInterrupted ( ) check from @ ThreadInterrupt . N.B : Attached patch is not complete . Documentation is not up to date and no test case is attached . Used for discussion only . . 
It would be handy to have a sort method on a Map or Property that would sort by the name/key since this is something that is commonly done . A possible implementation for a Property class might look like this : Properties.metaClass.sort = { new TreeMap ( delegate ) } Example usage would be : System.properties.sort ( ) . 
currently these are flagged as errors as normal public fields are disallowed . 
Provide a built-in slurper and builder for parsing and creating JSON payloads . This issue was initially triggered by the discussions around GEP-7 , for adding JSON support to Groovy : . 
Please , see . It would be nice to have groovy http : //server/script.groovy . 
similarly we may want a URL.asWritable ( ) like File too as well as URL.getText ( ) URL.eachByte ( ) URL.withReader ( ) etc . 
As described in a thread in the groovy user list here : An implementation of groupBy that receives a list or an array of closures as criteria for grouping would be useful for making nested groupings . def grouped = , , , , ] .groupBy ( { it.aa } , { it.bb } ) def expected = , ] ] , 22 : ] , 33 : ] ] , 33 : ] ] ] assert grouped == , ] assert grouped == ] assert grouped == null groupBy with one closure criterion would behave like the current implementation of groupBy . . 
The whole idea is similar to existing great @ Lazy annotation , but it differs in concept : instead of being applied to fields it is applied to methods , thus providing a wider field of use . When applied to getters it serves as an alternative to @ Lazy , but applied to other methods it provides what @ Lazy can t. Thus it eliminates the need for heavy refactoring in certain situations , by simply letting the user add the annotation to the method . Here is a suggestion of how it could work : @ Cached T createX ( ) { new T ( 1 , 2 , 3 ) } gets transformed into : private T $ createX $ result T $ createX ( ) { new T ( 1 , 2 , 3 ) } T createX ( ) { T $ result_local = $ createX $ result if ( $ result_local ! = null ) return $ result_local else { synchronized ( this ) { if ( $ createX $ result == null ) { $ createX $ result = $ createX ( ) } return $ createX $ result } } } This whole thing could be extended to cache different results of a method depending on its arguments , but it s a topic for a discussion . . 
The @ Immutable annotation has a list of known effectively immutable classes . There should be some way to provide an extensible list of class names or vouch for a particular field s immutability . Possible ways to implement might look like the examples below : @ Immutable class Person { String name @ KnownImmutable MyUuid id } @ KnownImmutables ( ) @ Immutable class Person { String name MyDate dob MuUuid id } . 
