namespaced navigation like Node root namespaced doc Namespace xsd new Namespace http xsd def root 91 93 def e root 91 93 91 93
project coin proposal binary literals found attached patch allows literals internal changes allow compiler create correct ints
develop AST transformations often difficult check particular transformation performs necessary example would like type checking verify type checker performed work particular AST node contains metadata inferred type Checking currently requires compilation trickery propose add AST transformation allows embedding tests example could test Field AST transformation way import ASTTest value def owner assert x Field int x
Similarily matches method Matcher matchesPartially method return true string matches Pattern characters could make string match Pattern
snipset def options def deep deep fields deep fails error signature method applicable argument types values Possible solutions subMap dump spread sleep long
retrieving node XML easy way clone node processing without changing original XML Currently used workaround def clonedNode new XmlParser xmlNode would lot easier Node object copy constructor clone would supported
Add annotation closure parameters allows document methods resolved closure example exec executable foo args bar baz class Project ExecResult exec DelegatesTo ExecSpec Closure closure
process ls println work BufferedInputStream added getText InputStream would nice
Provide Mock support pure means ProxyMetaClass Interceptors external mock library needed longer Make use Ranges Closures demanding behaviour Allow strict loose expectations terms sequence dependency demand specifications effected method calls
currently Observable versions Map List missing Set
Compile classes scripts along standard compilation process IDEA using modules within classes scripts defined
logging annotations currently allow change name logger instance class support change logging category logging category seems hardcoded fully qualified name annotated class would nice possibility change category Example package Commons category class MyClass would allow specify custom categories used logging configuration specify level Especially Grails framework special components services controller use custom logging category default prefixes component Using logging annotations breaks convention logging configuration components effectively changes
discussed would nice Immutable transform add copyWith method taking map returns new instance immutable class true class Person String first last def p new Person tim yates Returns instance def q first tim assert p Returns new instance def r first alice assert p assert alice assert yates
Basically implementation equivalent transform Griffon
needs kind reflection API traits programs reason traits runtime example one thing need know Spock whether method according Java reflection declared class X actually declared class inherited trait
Provide contains DGM method primitive arrays already count size methods primitive arrays contains isCase method Java programmers familiar contains provide approach
Iterable List Object tail drop take init dropRight takeRight missing added patch Method names Scala
would great alternate form min closure returns value compared rather comparison often trying choose desirable element list expression computes desirability Right x x lt gt wordy need write desirability expression twice also need explicit arguments closure would great maxv could write maxv maximum value Similarly minv trivial implement use global function def minv l Closure f return x f x lt gt f
send pull request GitHub method name Haskell Scala Kotlin use indices indexes implementation public static IntRange getIndices List self return new IntRange false 0 Usage
Remove duplicate entries Collection
gt analogous Collections empty Map gt evaluate false
Please see attached new suggested features GroovyJDK provided test cases demonstrate features Please feel free provide feedback Hein
Transform captured group something else assert 2 4 6 8 1 2 3 4 p Digit 2 new method String public static String replaceAll String self String regex Closure closure Matcher matcher regex self StringBuffer sb new StringBuffer String foundText 0 0 sb foundText sb return else return self
implement isCase Closures like public boolean isCase Object candidate return call candidate let Closures play switch cases like SwitchTest void testSwitchWithClosure switch 0 case true break default assert false switch 0 case false assert false switch 0 case 0 break default assert false switch 0 case candidate gt candidate 0 break default assert false way switch logic
using object1 object2 inconvenient suggestions object2 object2 object2 object2
Add BaseScript transformation allows setting base script class directly script say without compilation option Pull request
GPath syntax support xml namespaces XmlParser class creates special names xml elements namespaces elementName GPath node selection support format xml namespaces commonly used xml world Gpath would benefit using transparent way nodes whether binded namespaces
resulted size implemented StringBuffer size also implemented StringBuilder platforms
support annotations local variable declarations syntactically legal annotate local variable AST produced carry annotation use case AST builder Either like annotate local variable like AstSource def source println compiled new Date annotate property within closure DeclarationExpression like def result new AstBuilder phase AstSource source println compiled new Date getAnnotations method probably added DeclarationExpression support
find closure findAll closure methods really useful would also good List indexOf closure List indexOf int startIndex closure startIndex tells index start looking int List indicesOfAll closure return type may also List lt Integer gt whatever List lastIndexOf closure jdk sometimes important know elements fullfilling given condition list
new File input gt new File gt lt lt input
Add ability customize truth ie way boolean coercion happening letting users able define asBoolean method types way use myObject myObject evaluated boolean added method
Let code new methods extending core JDK classes Among foo
using scripting languages script defined using option access current line number attached patch defines new variable count holds line number current file parsed patched file
writing scripting languages helpful sometimes automatically access array containing current line split according pattern patch adds commandline option implements takes optional parameter split pattern used split pattern single space patched file
Regroup elements according closure criteria inside map index value criteria def expected def list 91 1 quot quot 2 quot b quot 93 def result assert 91 1 2 93 result 91 Integer 93 assert 91 quot quot quot b quot 93 result 91 String 93 assert 91 93 result 91 BigDecimal 93 assert 3
executing script via would sometimes useful define method BEGIN method END executed exactly BEGIN loop starts END loop ended files processed example def BEGIN def END println c c split 91 0 93 91 93 results 39 following 1 2 3 4 1 2 3 4 5 1 2 3 4 5 6 1 2 3 4 5 6 7 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 9 patch provides functionality additionally singular patch necessary happy provide
Part attraction languages JRuby flexible method dispatching part metaprogramming Self JavaScript style prototype based OOP addition class like ProtoObject class attached possible prototype based OOP ProtoObject possible write scripts like one create prototype object def p new ProtoObject add method self gt println hello self create another object def new ProtoObject println hello world set prototype p proto p prints hello world calls proto ProtoObject class similar Expando Expando sets current object delegate Closure 8211 therefore work property multithreading ProtoObject class passing first argument Closure Besides closure delegate used method search within closure code property access direct user write anyway explicit self first argument probably okay
Deleting directory including subdirectories tedious task method File like deleteRecursively would really help currently using already qutie nice code like def dataDir new File path def dirs Deleting else dirs lt lt Deleting directory could new File dir similar
Provide way get result addition 2 Maps eg assert terms Map semantics would take priority duplicate keys left right Considering Java blindly adds elements given map perhaps right side take precedence assert others think Original email thread
working Maps two scenarios want special default value key exist ie null want create new object key exist Proposed syntax def map new HashMap defaultValue xxx x assert assert xxx map 91 93 x New assert x New assert 1 assert map 91 93 New x assert x New assert 1 assert Abstract specify constant value closure creating map getting values key exist constant returned result running closure missing key parameter closure Note checking key exist sufficient check whether returns null Maps contain null values Implementation note suggest implement using wrapper DefaultValueMap handles default case methods get simply forwarded wrapped Map get looks like public Object get Object key containsKey key return defaultValue return key Open questions happens closure returns null Maybe new pair added case want add new exception
File GDK following methods void eachDir closure void eachFile closure void eachFileMatch filter closure void eachFileRecurse closure coherence would good void eachDirMatch filter closure void eachDirRecurse closure See discussion dev mailing list
synchronize expression
would good oos lt lt object shorthand object
Wii currently input output gt similar suggestion mirror Object variants ois oos gt would make setting proxy type objects sockets streamlined
John Wilson suggested improved syntax catching several exceptions suggested Java would thought trivial try Field field someField someValue catch SecurityException NoSuchFieldException e something else exception
def lists assert Set Set
need add support propertyMissing well methodMissing Example getters String name gt setters String name Object value gt
trying use XmlSlurper process xml nested elements text need get text one level time text method returns text childrend see anything would bring back local sample console gt def model new XmlSlurper lt aModel gt lt aParent bubba gt text lt aChild gt child text lt gt lt gt lt gt gt 91 0 93 gt gt Result textchild text
transpose method like Ruby transpose method arrays Python zip method expected behaviour assert assert transpose 91 39 39 39 b 39 93 91 1 2 3 93 assert transpose 91 1 2 3 93 91 4 5 6 93 assert transpose 91 1 2 3 93 91 4 5 93 91 9 93 91 6 7 8 93 assert transpose 91 1 2 3 93 assert transpose
ObservableMap fire PropertyChangeEvents put putAll called work decorator Maps none passed argument wrap HashMap Jochen suggested closure may optionally used discriminate property may fire event value changes useful constructing observable Expandos following code filter methods added Expando def bean new Expando new ObservableMap instanceof Closure Java trigger previous value null trigger previousValue newValue hello trigger value Closure idem even value changed
would nice support subscript access BitSet objects def bitSet new BitSet bitSet true bitSet true def value bitSet def subSet bitSet
Currently list invokes method items list would useful also support list invokes method items list recursively lists within list def assert 2 assert animalLists assert animalLists
would cool keyword could used coerce strings enum values Since currently throws exception adding functionality impact existing code
recently came across situation wanted initialize JCE Certificate directly URL wanted def cfUrl def cf def newRootCert Putting aside fact methods return closure return value going create separate JIRA currently withInputStream method URL could something like work around rather Groovier way def newRootCert attached patch add tests find existing tests matter sure best way handle would
hi talked james liked idea adding simple Closure c easily run things new threads example thread process long running process something else runs
mocks classes dynamic methods properties One example Grails domain objects would use implemented domain specific methods want mock GORM methods
frequently run across situation want create map two equal sized lists using one list keys second list values Maybe missing something seem find compact way require loop intermediate variable best come add method Map List keylist List valuelist gt assert int lt keylist valuelist delegate allows call putEach Map passing two equal sized lists assert 91 93 91 39 key1 39 39 key2 39 39 key3 39 93 91 39 value1 39 39 value2 39 39 value3 39 93 91 39 key1 39 39 value1 39 39 key2 39 39 value2 39 39 key3 39 39 value3 39 93 Since seems generally useful might something worth adding base GDK
Many methods GDK could reflect generic collections example adding two plus obtaining elements getAt affect runtime semantics respective methods make powerful static analyzes possible
new Bindable annotation great reduces amount boilerplate code required beans next logical step Identity annotation applied one attributes telling properties define identity business key bean object equals hashCode toString would behave accordingly May related sure marked Fix
Allow use compiler flag enable type checking classes methods except classes methods annotated TypeUnchecked annotation another antonym TypeChecked NotTypeChecked RuntimeTypeChecked TestInProduction YouNeedExtraUnitTestsForThis large projects hundreds classes want type checking 99 code would much boilerplate remember put TypeChecked annotations every class would also require us refactor methods containing dynamic code separate classes satisfy TypeChecked contract would better compiler flag reverse type checking contract everything type checked except classes methods explicitly marked allowing dynamic code Discussed Guillaume Laforge talk GR8Conf 2012 Copenhagen agreed would good addition open Jira ticket Another audience member request well
ObservableList provides similar behavior List also fire events whenever elements added removed cleared multi via allAll removeAll retainAll
GDK convenience methods wrap SimpleDateFormat new Date probably added Calendar Would complimentary parse method appropriate
jira document fact annotation written discussion still debate whether move contrib area issue updated change made Cheers Paul
Based mailing list feedback seems like split worthwhile partition almost easily replicated using groupBy maybe worth functionality findAll returns accepted rejected elements two lists
Currently possible create instance methods file new File line println currently add static methods thread process long running process
current suggestion use PackageScope AST macro
provides convenient encodeBase64 method byte would even convenient also encodeHex method byte See encodeBase64 Apache Commons Codec project provides implementation hex encoder would also trivial implement scratch feature would immensely convenient working checksums
explained following thread Scals provides stripMargin method strings helpful overall situations something fancier covered default behavior user roll impl Link Scala api docs
suggest introduce new AST transformation InheritConstructors placed class class annotation inherit constructors super class example class int arg String arg InheritConstructors class B extends class B equal class B extends B super B int arg super arg B String arg super arg think useful especially defining exceptions
makes working regular expressions much easier Java still couple holes implementation attached patch adds couple simple methods make regular expressions much easier use One common use cases search string regular expression pattern match found something matched value Currently recommended way create matcher use indexes work matches might found assert 10292 New York NY 10292 5 91 0 93 try string actually match regular expression get IndexOutOfBoundException safe need check matches requires entire string match see string actually def New York NY 5 91 0 93 def zip zip also inconsistent behavior regular expression happens capture groups returns array containing match capture groups forcing index array actually get match want assert c foo car baz 91 0 93 91 1 93 already added closure aware replace method String class patch adds complimentary find method string return string matched closure without needing worry matcher objects array indexes either call without closure get full found match back even groups assert 10292 New York NY 10292 5 safely returns null match found clean boilerplate safety checks quite bit user check null using truth want def zip New York NY 5 returns null zip want work capture groups manipulate value pass closure find method passed full match well capture groups collection based regular expression methods work capture groups match passed closure assert bar foo bar baz match gt return match one capture group assert b foo bar baz match firstLetter gt return firstLetter many capture groups passed closure full match assert 2339999 adsf adsf 3 3 4 match areaCode exchange stationNumber gt assert match assert null areaCode assert 233 exchange assert 9999 stationNumber return exchange stationNumber patch also includes number unit tests exercise demonstrate functionality get traffic blog post explaning regular expressions think people struggle bit current implementation think patch makes working regular expressions much easier intuitive
Ages ago wrote spell checker gives helpful information case MissingMethodExeption Missing Property Exception thrown recently picked finished patch uses reflection find missing methods low edit distance relative requested method also use edit distance method rank method probable solution displayed first performance impact isolated properties Methods constructors know case impact working program taken consideration unit tests partial era complete metrics coverage currently weak Missing method gt 10 ERROR signature method static applicable argument types values 91 10 93 Possible solutions valueOf valueOf int valueOf int gt Missing Constructor new Integer new Object ERROR Could find matching constructor Possible solutions int Missing Constructor new ERROR property xy class Possible solutions x
swing models follow naming standard common operations like get int set int element clear provide iterator method make sense request enhance Swing classes models additional methods bridge gap useful methods port
Please add option grape generate ivy dependencies command line like options example command grape resolve poi Could generate following output lt dependency poi gt lt dependency gt
File convenient methods like File eachLine File splitEachLine others way specify encoding reading example File eachLine String charSet Closure c method cource write new InputStreamReader new FileInputStream new File charSet proposal add encoding method GDK enhancement method used like new File args println reference write EMC definition method encoding like cs gt new InputStreamReader new FileInputStream delegate cs GDK equivalents methods enough
Currently need edit make Grape aware new Maven2 repository address add new annotation GrapeResolver http Grab
InputStream URL File getText method byte patch add method getBytes ex File URL http ByteArrayInputStream 91 93 byte
Sometimes troubleshooting issues helpful know class compiled one version run incompatible version Currently classes compiler leaves signs version behind annotation introduced store version subsequently retrieved know origin class
See
Currently equality extends arrays lists sets maps Example assert passes assert Set Set fails surprising ungroovy would nice equality sets maps drawback would make equality inconsistent lookup results two sets equal yields different results hand problem already exists list equality maps one could avoid lookup inconsistency using equality values would good discussion proposal
Sometimes want curry left hand side always fake rewriting reversed method Closure manually functional languages support currying right arbitrary index rcurry method allows examples like def divide b gt b def halver 2 assert halver 8 4 ncurry method would allow example curry middle parameter three argument method curry middle param utility method Collections binarySearch List list Object key Comparator c def catSearcher amp 1 cat def result catSearcher myList myComparator
Iterating date intervals currently possible using following code def start new GregorianCalendar 2010 1 def end new GregorianCalendar 2010 31 def current start current lt end println current following style numbers iterated groovier code end println start println Proposed implementation upTo lt lt Date end Closure c gt def next delegate next lt end next downTo lt lt Date start Closure c gt def next delegate next gt start next next
Unix tr translation command would good support something similar Translations similar tr achieved using regular expressions notation required much compact implementation much efficient
kind code write setting using engine often fairly similar syntactic sugar might improve look code polyglot scenarios
would useful support assert hello Hello
using nix shell replacement would useful support following assert assert 1234567 8 assert x assert x
minor useful convenience concurrent scenarios would useful Synchronized annotation similar offered project Lombok makes easier follow good practice without remember rules
regards thread user list take n method would really useful addition codebase assumed work similar languages def assert 0 assert 1 assert 4 method work Collection String Map lazily Iterator Reader InputStream
Mister Jamie McCrindle suggested new sockets server sockets Closure Closure Jamie ideas methods
would useful support something like F compose gt gt operator Closures def twice gt 2 def inc b gt b 1 def f inc gt gt twice def g x gt twice inc x longhand equivalent assert f 10 22 assert g 10 22 def string2char def p Integer amp toHexString gt gt string2char gt gt Character amp toUpperCase assert p 15 F def multiply b gt b def identity gt def sq identity gt gt multiply assert 1 5 sq
Implement closure memoization like GPars
add support WithReadLock WithWriteLock declarative synchronization per discussion commit looking feedback code import public class ResourceProvider private final Map lt String String gt data new HashMap lt String String gt WithReadLock public String getResource String key throws Exception return key WithWriteLock public void refresh throws Exception resources memory Becomes Code import import public class ResourceProvider private final ReadWriteLock reentrantlock new ReentrantReadWriteLock private final Map lt String String gt data new HashMap lt String String gt public String getResource String key throws Exception try return key finally public void refresh throws Exception try resources memory finally also specify lock like import public class ResourceProvider private final ReadWriteLock myLock new ReentrantReadWriteLock private final Map lt String String gt data new HashMap lt String String gt WithReadLock myLock public String getResource String key throws Exception return key WithWriteLock myLock public void refresh throws Exception resources memory case code becomes public class ResourceProvider private final ReadWriteLock myLock new ReentrantReadWriteLock private final Map lt String String gt data new HashMap lt String String gt public String getResource String key throws Exception try return key finally public void refresh throws Exception try resources memory finally
Add trampoline capabilities closures avoid StackOverflowException using closures lots recursive calls Patch contributed Václav
Following discussion AST Transformation allows transparent script interruption worker thread interrupted adds thread interruption checks several points code closures different types loops method first statement attached file preliminary implementation propagate CompilationUnit yet found properly simple script use tests Feel free review patch
DGM min Map map Closure closure shorthand closure Likewise max
Write AST Transformation allows user create custom interrupt conditions instead check ThreadInterrupt Attached patch complete Documentation date test case attached Used discussion
would handy sort method Map Property would sort since something commonly done possible implementation Property class might look like new TreeMap delegate Example usage would
currently flagged errors normal public fields disallowed
Provide slurper builder parsing creating JSON payloads issue initially triggered discussions around adding JSON support
Please see would nice http
similarly may want like File well etc
described thread user list implementation groupBy receives list array closures criteria grouping would useful making nested groupings def grouped def expected 22 33 33 assert grouped assert grouped assert grouped null groupBy one closure criterion would behave like current implementation groupBy
whole idea similar existing great Lazy annotation differs concept instead applied fields applied methods thus providing wider field use applied getters serves alternative Lazy applied methods provides Lazy Thus eliminates need heavy refactoring certain situations simply letting user add annotation method suggestion could work Cached createX new 1 2 3 gets transformed private createX result createX new 1 2 3 createX createX result null return else synchronized createX result null createX result createX return createX result whole thing could extended cache different results method depending arguments topic discussion
Immutable annotation list known effectively immutable classes way provide extensible list class names vouch particular field immutability Possible ways implement might look like examples Immutable class Person String name KnownImmutable MyUuid id KnownImmutables Immutable class Person String name MyDate dob MuUuid id
